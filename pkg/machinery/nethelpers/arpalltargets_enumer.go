// Code generated by "enumer -type=ARPAllTargets,ARPValidate,AddressFlag,AddressSortAlgorithm,ADSelect,BondMode,BondXmitHashPolicy,ConntrackState,DefaultAction,Duplex,Family,LACPRate,LinkFlag,LinkType,MatchOperator,NfTablesChainHook,NfTablesChainPriority,NfTablesVerdict,OperationalState,Port,PrimaryReselect,Protocol,RouteFlag,RouteProtocol,RouteType,RoutingTable,Scope,Status,VLANProtocol -linecomment -text"; DO NOT EDIT.

package nethelpers

import (
	"fmt"
	"strings"
)

const _ARPAllTargetsName = "anyall"

var _ARPAllTargetsIndex = [...]uint8{0, 3, 6}

const _ARPAllTargetsLowerName = "anyall"

func (i ARPAllTargets) String() string {
	if i >= ARPAllTargets(len(_ARPAllTargetsIndex)-1) {
		return fmt.Sprintf("ARPAllTargets(%d)", i)
	}
	return _ARPAllTargetsName[_ARPAllTargetsIndex[i]:_ARPAllTargetsIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _ARPAllTargetsNoOp() {
	var x [1]struct{}
	_ = x[ARPAllTargetsAny-(0)]
	_ = x[ARPAllTargetsAll-(1)]
}

var _ARPAllTargetsValues = []ARPAllTargets{ARPAllTargetsAny, ARPAllTargetsAll}

var _ARPAllTargetsNameToValueMap = map[string]ARPAllTargets{
	_ARPAllTargetsName[0:3]:      ARPAllTargetsAny,
	_ARPAllTargetsLowerName[0:3]: ARPAllTargetsAny,
	_ARPAllTargetsName[3:6]:      ARPAllTargetsAll,
	_ARPAllTargetsLowerName[3:6]: ARPAllTargetsAll,
}

var _ARPAllTargetsNames = []string{
	_ARPAllTargetsName[0:3],
	_ARPAllTargetsName[3:6],
}

// ARPAllTargetsString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func ARPAllTargetsString(s string) (ARPAllTargets, error) {
	if val, ok := _ARPAllTargetsNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _ARPAllTargetsNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to ARPAllTargets values", s)
}

// ARPAllTargetsValues returns all values of the enum
func ARPAllTargetsValues() []ARPAllTargets {
	return _ARPAllTargetsValues
}

// ARPAllTargetsStrings returns a slice of all String values of the enum
func ARPAllTargetsStrings() []string {
	strs := make([]string, len(_ARPAllTargetsNames))
	copy(strs, _ARPAllTargetsNames)
	return strs
}

// IsAARPAllTargets returns "true" if the value is listed in the enum definition. "false" otherwise
func (i ARPAllTargets) IsAARPAllTargets() bool {
	for _, v := range _ARPAllTargetsValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for ARPAllTargets
func (i ARPAllTargets) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for ARPAllTargets
func (i *ARPAllTargets) UnmarshalText(text []byte) error {
	var err error
	*i, err = ARPAllTargetsString(string(text))
	return err
}

const _ARPValidateName = "noneactivebackupall"

var _ARPValidateIndex = [...]uint8{0, 4, 10, 16, 19}

const _ARPValidateLowerName = "noneactivebackupall"

func (i ARPValidate) String() string {
	if i >= ARPValidate(len(_ARPValidateIndex)-1) {
		return fmt.Sprintf("ARPValidate(%d)", i)
	}
	return _ARPValidateName[_ARPValidateIndex[i]:_ARPValidateIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _ARPValidateNoOp() {
	var x [1]struct{}
	_ = x[ARPValidateNone-(0)]
	_ = x[ARPValidateActive-(1)]
	_ = x[ARPValidateBackup-(2)]
	_ = x[ARPValidateAll-(3)]
}

var _ARPValidateValues = []ARPValidate{ARPValidateNone, ARPValidateActive, ARPValidateBackup, ARPValidateAll}

var _ARPValidateNameToValueMap = map[string]ARPValidate{
	_ARPValidateName[0:4]:        ARPValidateNone,
	_ARPValidateLowerName[0:4]:   ARPValidateNone,
	_ARPValidateName[4:10]:       ARPValidateActive,
	_ARPValidateLowerName[4:10]:  ARPValidateActive,
	_ARPValidateName[10:16]:      ARPValidateBackup,
	_ARPValidateLowerName[10:16]: ARPValidateBackup,
	_ARPValidateName[16:19]:      ARPValidateAll,
	_ARPValidateLowerName[16:19]: ARPValidateAll,
}

var _ARPValidateNames = []string{
	_ARPValidateName[0:4],
	_ARPValidateName[4:10],
	_ARPValidateName[10:16],
	_ARPValidateName[16:19],
}

// ARPValidateString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func ARPValidateString(s string) (ARPValidate, error) {
	if val, ok := _ARPValidateNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _ARPValidateNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to ARPValidate values", s)
}

// ARPValidateValues returns all values of the enum
func ARPValidateValues() []ARPValidate {
	return _ARPValidateValues
}

// ARPValidateStrings returns a slice of all String values of the enum
func ARPValidateStrings() []string {
	strs := make([]string, len(_ARPValidateNames))
	copy(strs, _ARPValidateNames)
	return strs
}

// IsAARPValidate returns "true" if the value is listed in the enum definition. "false" otherwise
func (i ARPValidate) IsAARPValidate() bool {
	for _, v := range _ARPValidateValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for ARPValidate
func (i ARPValidate) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for ARPValidate
func (i *ARPValidate) UnmarshalText(text []byte) error {
	var err error
	*i, err = ARPValidateString(string(text))
	return err
}

const _AddressFlagName = "temporarynodadoptimisticdadfailedhomeaddressdeprecatedtentativepermanentmngmtmpaddrnoprefixroutemcautojoinstableprivacy"
const _AddressFlagLowerName = "temporarynodadoptimisticdadfailedhomeaddressdeprecatedtentativepermanentmngmtmpaddrnoprefixroutemcautojoinstableprivacy"

var _AddressFlagMap = map[AddressFlag]string{
	1:    _AddressFlagName[0:9],
	2:    _AddressFlagName[9:14],
	4:    _AddressFlagName[14:24],
	8:    _AddressFlagName[24:33],
	16:   _AddressFlagName[33:44],
	32:   _AddressFlagName[44:54],
	64:   _AddressFlagName[54:63],
	128:  _AddressFlagName[63:72],
	256:  _AddressFlagName[72:83],
	512:  _AddressFlagName[83:96],
	1024: _AddressFlagName[96:106],
	2048: _AddressFlagName[106:119],
}

func (i AddressFlag) String() string {
	if str, ok := _AddressFlagMap[i]; ok {
		return str
	}
	return fmt.Sprintf("AddressFlag(%d)", i)
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _AddressFlagNoOp() {
	var x [1]struct{}
	_ = x[AddressTemporary-(1)]
	_ = x[AddressNoDAD-(2)]
	_ = x[AddressOptimistic-(4)]
	_ = x[AddressDADFailed-(8)]
	_ = x[AddressHome-(16)]
	_ = x[AddressDeprecated-(32)]
	_ = x[AddressTentative-(64)]
	_ = x[AddressPermanent-(128)]
	_ = x[AddressManagementTemp-(256)]
	_ = x[AddressNoPrefixRoute-(512)]
	_ = x[AddressMCAutoJoin-(1024)]
	_ = x[AddressStablePrivacy-(2048)]
}

var _AddressFlagValues = []AddressFlag{AddressTemporary, AddressNoDAD, AddressOptimistic, AddressDADFailed, AddressHome, AddressDeprecated, AddressTentative, AddressPermanent, AddressManagementTemp, AddressNoPrefixRoute, AddressMCAutoJoin, AddressStablePrivacy}

var _AddressFlagNameToValueMap = map[string]AddressFlag{
	_AddressFlagName[0:9]:          AddressTemporary,
	_AddressFlagLowerName[0:9]:     AddressTemporary,
	_AddressFlagName[9:14]:         AddressNoDAD,
	_AddressFlagLowerName[9:14]:    AddressNoDAD,
	_AddressFlagName[14:24]:        AddressOptimistic,
	_AddressFlagLowerName[14:24]:   AddressOptimistic,
	_AddressFlagName[24:33]:        AddressDADFailed,
	_AddressFlagLowerName[24:33]:   AddressDADFailed,
	_AddressFlagName[33:44]:        AddressHome,
	_AddressFlagLowerName[33:44]:   AddressHome,
	_AddressFlagName[44:54]:        AddressDeprecated,
	_AddressFlagLowerName[44:54]:   AddressDeprecated,
	_AddressFlagName[54:63]:        AddressTentative,
	_AddressFlagLowerName[54:63]:   AddressTentative,
	_AddressFlagName[63:72]:        AddressPermanent,
	_AddressFlagLowerName[63:72]:   AddressPermanent,
	_AddressFlagName[72:83]:        AddressManagementTemp,
	_AddressFlagLowerName[72:83]:   AddressManagementTemp,
	_AddressFlagName[83:96]:        AddressNoPrefixRoute,
	_AddressFlagLowerName[83:96]:   AddressNoPrefixRoute,
	_AddressFlagName[96:106]:       AddressMCAutoJoin,
	_AddressFlagLowerName[96:106]:  AddressMCAutoJoin,
	_AddressFlagName[106:119]:      AddressStablePrivacy,
	_AddressFlagLowerName[106:119]: AddressStablePrivacy,
}

var _AddressFlagNames = []string{
	_AddressFlagName[0:9],
	_AddressFlagName[9:14],
	_AddressFlagName[14:24],
	_AddressFlagName[24:33],
	_AddressFlagName[33:44],
	_AddressFlagName[44:54],
	_AddressFlagName[54:63],
	_AddressFlagName[63:72],
	_AddressFlagName[72:83],
	_AddressFlagName[83:96],
	_AddressFlagName[96:106],
	_AddressFlagName[106:119],
}

// AddressFlagString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func AddressFlagString(s string) (AddressFlag, error) {
	if val, ok := _AddressFlagNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _AddressFlagNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to AddressFlag values", s)
}

// AddressFlagValues returns all values of the enum
func AddressFlagValues() []AddressFlag {
	return _AddressFlagValues
}

// AddressFlagStrings returns a slice of all String values of the enum
func AddressFlagStrings() []string {
	strs := make([]string, len(_AddressFlagNames))
	copy(strs, _AddressFlagNames)
	return strs
}

// IsAAddressFlag returns "true" if the value is listed in the enum definition. "false" otherwise
func (i AddressFlag) IsAAddressFlag() bool {
	_, ok := _AddressFlagMap[i]
	return ok
}

// MarshalText implements the encoding.TextMarshaler interface for AddressFlag
func (i AddressFlag) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for AddressFlag
func (i *AddressFlag) UnmarshalText(text []byte) error {
	var err error
	*i, err = AddressFlagString(string(text))
	return err
}

const _AddressSortAlgorithmName = "v1v2"

var _AddressSortAlgorithmIndex = [...]uint8{0, 2, 4}

const _AddressSortAlgorithmLowerName = "v1v2"

func (i AddressSortAlgorithm) String() string {
	if i < 0 || i >= AddressSortAlgorithm(len(_AddressSortAlgorithmIndex)-1) {
		return fmt.Sprintf("AddressSortAlgorithm(%d)", i)
	}
	return _AddressSortAlgorithmName[_AddressSortAlgorithmIndex[i]:_AddressSortAlgorithmIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _AddressSortAlgorithmNoOp() {
	var x [1]struct{}
	_ = x[AddressSortAlgorithmV1-(0)]
	_ = x[AddressSortAlgorithmV2-(1)]
}

var _AddressSortAlgorithmValues = []AddressSortAlgorithm{AddressSortAlgorithmV1, AddressSortAlgorithmV2}

var _AddressSortAlgorithmNameToValueMap = map[string]AddressSortAlgorithm{
	_AddressSortAlgorithmName[0:2]:      AddressSortAlgorithmV1,
	_AddressSortAlgorithmLowerName[0:2]: AddressSortAlgorithmV1,
	_AddressSortAlgorithmName[2:4]:      AddressSortAlgorithmV2,
	_AddressSortAlgorithmLowerName[2:4]: AddressSortAlgorithmV2,
}

var _AddressSortAlgorithmNames = []string{
	_AddressSortAlgorithmName[0:2],
	_AddressSortAlgorithmName[2:4],
}

// AddressSortAlgorithmString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func AddressSortAlgorithmString(s string) (AddressSortAlgorithm, error) {
	if val, ok := _AddressSortAlgorithmNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _AddressSortAlgorithmNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to AddressSortAlgorithm values", s)
}

// AddressSortAlgorithmValues returns all values of the enum
func AddressSortAlgorithmValues() []AddressSortAlgorithm {
	return _AddressSortAlgorithmValues
}

// AddressSortAlgorithmStrings returns a slice of all String values of the enum
func AddressSortAlgorithmStrings() []string {
	strs := make([]string, len(_AddressSortAlgorithmNames))
	copy(strs, _AddressSortAlgorithmNames)
	return strs
}

// IsAAddressSortAlgorithm returns "true" if the value is listed in the enum definition. "false" otherwise
func (i AddressSortAlgorithm) IsAAddressSortAlgorithm() bool {
	for _, v := range _AddressSortAlgorithmValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for AddressSortAlgorithm
func (i AddressSortAlgorithm) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for AddressSortAlgorithm
func (i *AddressSortAlgorithm) UnmarshalText(text []byte) error {
	var err error
	*i, err = AddressSortAlgorithmString(string(text))
	return err
}

const _ADSelectName = "stablebandwidthcount"

var _ADSelectIndex = [...]uint8{0, 6, 15, 20}

const _ADSelectLowerName = "stablebandwidthcount"

func (i ADSelect) String() string {
	if i >= ADSelect(len(_ADSelectIndex)-1) {
		return fmt.Sprintf("ADSelect(%d)", i)
	}
	return _ADSelectName[_ADSelectIndex[i]:_ADSelectIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _ADSelectNoOp() {
	var x [1]struct{}
	_ = x[ADSelectStable-(0)]
	_ = x[ADSelectBandwidth-(1)]
	_ = x[ADSelectCount-(2)]
}

var _ADSelectValues = []ADSelect{ADSelectStable, ADSelectBandwidth, ADSelectCount}

var _ADSelectNameToValueMap = map[string]ADSelect{
	_ADSelectName[0:6]:        ADSelectStable,
	_ADSelectLowerName[0:6]:   ADSelectStable,
	_ADSelectName[6:15]:       ADSelectBandwidth,
	_ADSelectLowerName[6:15]:  ADSelectBandwidth,
	_ADSelectName[15:20]:      ADSelectCount,
	_ADSelectLowerName[15:20]: ADSelectCount,
}

var _ADSelectNames = []string{
	_ADSelectName[0:6],
	_ADSelectName[6:15],
	_ADSelectName[15:20],
}

// ADSelectString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func ADSelectString(s string) (ADSelect, error) {
	if val, ok := _ADSelectNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _ADSelectNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to ADSelect values", s)
}

// ADSelectValues returns all values of the enum
func ADSelectValues() []ADSelect {
	return _ADSelectValues
}

// ADSelectStrings returns a slice of all String values of the enum
func ADSelectStrings() []string {
	strs := make([]string, len(_ADSelectNames))
	copy(strs, _ADSelectNames)
	return strs
}

// IsAADSelect returns "true" if the value is listed in the enum definition. "false" otherwise
func (i ADSelect) IsAADSelect() bool {
	for _, v := range _ADSelectValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for ADSelect
func (i ADSelect) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for ADSelect
func (i *ADSelect) UnmarshalText(text []byte) error {
	var err error
	*i, err = ADSelectString(string(text))
	return err
}

const _BondModeName = "balance-rractive-backupbalance-xorbroadcast802.3adbalance-tlbbalance-alb"

var _BondModeIndex = [...]uint8{0, 10, 23, 34, 43, 50, 61, 72}

const _BondModeLowerName = "balance-rractive-backupbalance-xorbroadcast802.3adbalance-tlbbalance-alb"

func (i BondMode) String() string {
	if i >= BondMode(len(_BondModeIndex)-1) {
		return fmt.Sprintf("BondMode(%d)", i)
	}
	return _BondModeName[_BondModeIndex[i]:_BondModeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _BondModeNoOp() {
	var x [1]struct{}
	_ = x[BondModeRoundrobin-(0)]
	_ = x[BondModeActiveBackup-(1)]
	_ = x[BondModeXOR-(2)]
	_ = x[BondModeBroadcast-(3)]
	_ = x[BondMode8023AD-(4)]
	_ = x[BondModeTLB-(5)]
	_ = x[BondModeALB-(6)]
}

var _BondModeValues = []BondMode{BondModeRoundrobin, BondModeActiveBackup, BondModeXOR, BondModeBroadcast, BondMode8023AD, BondModeTLB, BondModeALB}

var _BondModeNameToValueMap = map[string]BondMode{
	_BondModeName[0:10]:       BondModeRoundrobin,
	_BondModeLowerName[0:10]:  BondModeRoundrobin,
	_BondModeName[10:23]:      BondModeActiveBackup,
	_BondModeLowerName[10:23]: BondModeActiveBackup,
	_BondModeName[23:34]:      BondModeXOR,
	_BondModeLowerName[23:34]: BondModeXOR,
	_BondModeName[34:43]:      BondModeBroadcast,
	_BondModeLowerName[34:43]: BondModeBroadcast,
	_BondModeName[43:50]:      BondMode8023AD,
	_BondModeLowerName[43:50]: BondMode8023AD,
	_BondModeName[50:61]:      BondModeTLB,
	_BondModeLowerName[50:61]: BondModeTLB,
	_BondModeName[61:72]:      BondModeALB,
	_BondModeLowerName[61:72]: BondModeALB,
}

var _BondModeNames = []string{
	_BondModeName[0:10],
	_BondModeName[10:23],
	_BondModeName[23:34],
	_BondModeName[34:43],
	_BondModeName[43:50],
	_BondModeName[50:61],
	_BondModeName[61:72],
}

// BondModeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func BondModeString(s string) (BondMode, error) {
	if val, ok := _BondModeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _BondModeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to BondMode values", s)
}

// BondModeValues returns all values of the enum
func BondModeValues() []BondMode {
	return _BondModeValues
}

// BondModeStrings returns a slice of all String values of the enum
func BondModeStrings() []string {
	strs := make([]string, len(_BondModeNames))
	copy(strs, _BondModeNames)
	return strs
}

// IsABondMode returns "true" if the value is listed in the enum definition. "false" otherwise
func (i BondMode) IsABondMode() bool {
	for _, v := range _BondModeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for BondMode
func (i BondMode) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for BondMode
func (i *BondMode) UnmarshalText(text []byte) error {
	var err error
	*i, err = BondModeString(string(text))
	return err
}

const _BondXmitHashPolicyName = "layer2layer3+4layer2+3encap2+3encap3+4"

var _BondXmitHashPolicyIndex = [...]uint8{0, 6, 14, 22, 30, 38}

const _BondXmitHashPolicyLowerName = "layer2layer3+4layer2+3encap2+3encap3+4"

func (i BondXmitHashPolicy) String() string {
	if i >= BondXmitHashPolicy(len(_BondXmitHashPolicyIndex)-1) {
		return fmt.Sprintf("BondXmitHashPolicy(%d)", i)
	}
	return _BondXmitHashPolicyName[_BondXmitHashPolicyIndex[i]:_BondXmitHashPolicyIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _BondXmitHashPolicyNoOp() {
	var x [1]struct{}
	_ = x[BondXmitPolicyLayer2-(0)]
	_ = x[BondXmitPolicyLayer34-(1)]
	_ = x[BondXmitPolicyLayer23-(2)]
	_ = x[BondXmitPolicyEncap23-(3)]
	_ = x[BondXmitPolicyEncap34-(4)]
}

var _BondXmitHashPolicyValues = []BondXmitHashPolicy{BondXmitPolicyLayer2, BondXmitPolicyLayer34, BondXmitPolicyLayer23, BondXmitPolicyEncap23, BondXmitPolicyEncap34}

var _BondXmitHashPolicyNameToValueMap = map[string]BondXmitHashPolicy{
	_BondXmitHashPolicyName[0:6]:        BondXmitPolicyLayer2,
	_BondXmitHashPolicyLowerName[0:6]:   BondXmitPolicyLayer2,
	_BondXmitHashPolicyName[6:14]:       BondXmitPolicyLayer34,
	_BondXmitHashPolicyLowerName[6:14]:  BondXmitPolicyLayer34,
	_BondXmitHashPolicyName[14:22]:      BondXmitPolicyLayer23,
	_BondXmitHashPolicyLowerName[14:22]: BondXmitPolicyLayer23,
	_BondXmitHashPolicyName[22:30]:      BondXmitPolicyEncap23,
	_BondXmitHashPolicyLowerName[22:30]: BondXmitPolicyEncap23,
	_BondXmitHashPolicyName[30:38]:      BondXmitPolicyEncap34,
	_BondXmitHashPolicyLowerName[30:38]: BondXmitPolicyEncap34,
}

var _BondXmitHashPolicyNames = []string{
	_BondXmitHashPolicyName[0:6],
	_BondXmitHashPolicyName[6:14],
	_BondXmitHashPolicyName[14:22],
	_BondXmitHashPolicyName[22:30],
	_BondXmitHashPolicyName[30:38],
}

// BondXmitHashPolicyString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func BondXmitHashPolicyString(s string) (BondXmitHashPolicy, error) {
	if val, ok := _BondXmitHashPolicyNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _BondXmitHashPolicyNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to BondXmitHashPolicy values", s)
}

// BondXmitHashPolicyValues returns all values of the enum
func BondXmitHashPolicyValues() []BondXmitHashPolicy {
	return _BondXmitHashPolicyValues
}

// BondXmitHashPolicyStrings returns a slice of all String values of the enum
func BondXmitHashPolicyStrings() []string {
	strs := make([]string, len(_BondXmitHashPolicyNames))
	copy(strs, _BondXmitHashPolicyNames)
	return strs
}

// IsABondXmitHashPolicy returns "true" if the value is listed in the enum definition. "false" otherwise
func (i BondXmitHashPolicy) IsABondXmitHashPolicy() bool {
	for _, v := range _BondXmitHashPolicyValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for BondXmitHashPolicy
func (i BondXmitHashPolicy) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for BondXmitHashPolicy
func (i *BondXmitHashPolicy) UnmarshalText(text []byte) error {
	var err error
	*i, err = BondXmitHashPolicyString(string(text))
	return err
}

const (
	_ConntrackStateName_0      = "invalidestablished"
	_ConntrackStateLowerName_0 = "invalidestablished"
	_ConntrackStateName_1      = "related"
	_ConntrackStateLowerName_1 = "related"
	_ConntrackStateName_2      = "new"
	_ConntrackStateLowerName_2 = "new"
)

var (
	_ConntrackStateIndex_0 = [...]uint8{0, 7, 18}
	_ConntrackStateIndex_1 = [...]uint8{0, 7}
	_ConntrackStateIndex_2 = [...]uint8{0, 3}
)

func (i ConntrackState) String() string {
	switch {
	case 1 <= i && i <= 2:
		i -= 1
		return _ConntrackStateName_0[_ConntrackStateIndex_0[i]:_ConntrackStateIndex_0[i+1]]
	case i == 4:
		return _ConntrackStateName_1
	case i == 8:
		return _ConntrackStateName_2
	default:
		return fmt.Sprintf("ConntrackState(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _ConntrackStateNoOp() {
	var x [1]struct{}
	_ = x[ConntrackStateInvalid-(1)]
	_ = x[ConntrackStateEstablished-(2)]
	_ = x[ConntrackStateRelated-(4)]
	_ = x[ConntrackStateNew-(8)]
}

var _ConntrackStateValues = []ConntrackState{ConntrackStateInvalid, ConntrackStateEstablished, ConntrackStateRelated, ConntrackStateNew}

var _ConntrackStateNameToValueMap = map[string]ConntrackState{
	_ConntrackStateName_0[0:7]:       ConntrackStateInvalid,
	_ConntrackStateLowerName_0[0:7]:  ConntrackStateInvalid,
	_ConntrackStateName_0[7:18]:      ConntrackStateEstablished,
	_ConntrackStateLowerName_0[7:18]: ConntrackStateEstablished,
	_ConntrackStateName_1[0:7]:       ConntrackStateRelated,
	_ConntrackStateLowerName_1[0:7]:  ConntrackStateRelated,
	_ConntrackStateName_2[0:3]:       ConntrackStateNew,
	_ConntrackStateLowerName_2[0:3]:  ConntrackStateNew,
}

var _ConntrackStateNames = []string{
	_ConntrackStateName_0[0:7],
	_ConntrackStateName_0[7:18],
	_ConntrackStateName_1[0:7],
	_ConntrackStateName_2[0:3],
}

// ConntrackStateString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func ConntrackStateString(s string) (ConntrackState, error) {
	if val, ok := _ConntrackStateNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _ConntrackStateNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to ConntrackState values", s)
}

// ConntrackStateValues returns all values of the enum
func ConntrackStateValues() []ConntrackState {
	return _ConntrackStateValues
}

// ConntrackStateStrings returns a slice of all String values of the enum
func ConntrackStateStrings() []string {
	strs := make([]string, len(_ConntrackStateNames))
	copy(strs, _ConntrackStateNames)
	return strs
}

// IsAConntrackState returns "true" if the value is listed in the enum definition. "false" otherwise
func (i ConntrackState) IsAConntrackState() bool {
	for _, v := range _ConntrackStateValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for ConntrackState
func (i ConntrackState) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for ConntrackState
func (i *ConntrackState) UnmarshalText(text []byte) error {
	var err error
	*i, err = ConntrackStateString(string(text))
	return err
}

const _DefaultActionName = "acceptblock"

var _DefaultActionIndex = [...]uint8{0, 6, 11}

const _DefaultActionLowerName = "acceptblock"

func (i DefaultAction) String() string {
	if i < 0 || i >= DefaultAction(len(_DefaultActionIndex)-1) {
		return fmt.Sprintf("DefaultAction(%d)", i)
	}
	return _DefaultActionName[_DefaultActionIndex[i]:_DefaultActionIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _DefaultActionNoOp() {
	var x [1]struct{}
	_ = x[DefaultActionAccept-(0)]
	_ = x[DefaultActionBlock-(1)]
}

var _DefaultActionValues = []DefaultAction{DefaultActionAccept, DefaultActionBlock}

var _DefaultActionNameToValueMap = map[string]DefaultAction{
	_DefaultActionName[0:6]:       DefaultActionAccept,
	_DefaultActionLowerName[0:6]:  DefaultActionAccept,
	_DefaultActionName[6:11]:      DefaultActionBlock,
	_DefaultActionLowerName[6:11]: DefaultActionBlock,
}

var _DefaultActionNames = []string{
	_DefaultActionName[0:6],
	_DefaultActionName[6:11],
}

// DefaultActionString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func DefaultActionString(s string) (DefaultAction, error) {
	if val, ok := _DefaultActionNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _DefaultActionNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to DefaultAction values", s)
}

// DefaultActionValues returns all values of the enum
func DefaultActionValues() []DefaultAction {
	return _DefaultActionValues
}

// DefaultActionStrings returns a slice of all String values of the enum
func DefaultActionStrings() []string {
	strs := make([]string, len(_DefaultActionNames))
	copy(strs, _DefaultActionNames)
	return strs
}

// IsADefaultAction returns "true" if the value is listed in the enum definition. "false" otherwise
func (i DefaultAction) IsADefaultAction() bool {
	for _, v := range _DefaultActionValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for DefaultAction
func (i DefaultAction) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for DefaultAction
func (i *DefaultAction) UnmarshalText(text []byte) error {
	var err error
	*i, err = DefaultActionString(string(text))
	return err
}

const (
	_DuplexName_0      = "HalfFull"
	_DuplexLowerName_0 = "halffull"
	_DuplexName_1      = "Unknown"
	_DuplexLowerName_1 = "unknown"
)

var (
	_DuplexIndex_0 = [...]uint8{0, 4, 8}
	_DuplexIndex_1 = [...]uint8{0, 7}
)

func (i Duplex) String() string {
	switch {
	case 0 <= i && i <= 1:
		return _DuplexName_0[_DuplexIndex_0[i]:_DuplexIndex_0[i+1]]
	case i == 255:
		return _DuplexName_1
	default:
		return fmt.Sprintf("Duplex(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _DuplexNoOp() {
	var x [1]struct{}
	_ = x[Half-(0)]
	_ = x[Full-(1)]
	_ = x[Unknown-(255)]
}

var _DuplexValues = []Duplex{Half, Full, Unknown}

var _DuplexNameToValueMap = map[string]Duplex{
	_DuplexName_0[0:4]:      Half,
	_DuplexLowerName_0[0:4]: Half,
	_DuplexName_0[4:8]:      Full,
	_DuplexLowerName_0[4:8]: Full,
	_DuplexName_1[0:7]:      Unknown,
	_DuplexLowerName_1[0:7]: Unknown,
}

var _DuplexNames = []string{
	_DuplexName_0[0:4],
	_DuplexName_0[4:8],
	_DuplexName_1[0:7],
}

// DuplexString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func DuplexString(s string) (Duplex, error) {
	if val, ok := _DuplexNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _DuplexNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Duplex values", s)
}

// DuplexValues returns all values of the enum
func DuplexValues() []Duplex {
	return _DuplexValues
}

// DuplexStrings returns a slice of all String values of the enum
func DuplexStrings() []string {
	strs := make([]string, len(_DuplexNames))
	copy(strs, _DuplexNames)
	return strs
}

// IsADuplex returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Duplex) IsADuplex() bool {
	for _, v := range _DuplexValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for Duplex
func (i Duplex) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Duplex
func (i *Duplex) UnmarshalText(text []byte) error {
	var err error
	*i, err = DuplexString(string(text))
	return err
}

const (
	_FamilyName_0      = "inet4"
	_FamilyLowerName_0 = "inet4"
	_FamilyName_1      = "inet6"
	_FamilyLowerName_1 = "inet6"
)

var (
	_FamilyIndex_0 = [...]uint8{0, 5}
	_FamilyIndex_1 = [...]uint8{0, 5}
)

func (i Family) String() string {
	switch {
	case i == 2:
		return _FamilyName_0
	case i == 10:
		return _FamilyName_1
	default:
		return fmt.Sprintf("Family(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _FamilyNoOp() {
	var x [1]struct{}
	_ = x[FamilyInet4-(2)]
	_ = x[FamilyInet6-(10)]
}

var _FamilyValues = []Family{FamilyInet4, FamilyInet6}

var _FamilyNameToValueMap = map[string]Family{
	_FamilyName_0[0:5]:      FamilyInet4,
	_FamilyLowerName_0[0:5]: FamilyInet4,
	_FamilyName_1[0:5]:      FamilyInet6,
	_FamilyLowerName_1[0:5]: FamilyInet6,
}

var _FamilyNames = []string{
	_FamilyName_0[0:5],
	_FamilyName_1[0:5],
}

// FamilyString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func FamilyString(s string) (Family, error) {
	if val, ok := _FamilyNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _FamilyNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Family values", s)
}

// FamilyValues returns all values of the enum
func FamilyValues() []Family {
	return _FamilyValues
}

// FamilyStrings returns a slice of all String values of the enum
func FamilyStrings() []string {
	strs := make([]string, len(_FamilyNames))
	copy(strs, _FamilyNames)
	return strs
}

// IsAFamily returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Family) IsAFamily() bool {
	for _, v := range _FamilyValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for Family
func (i Family) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Family
func (i *Family) UnmarshalText(text []byte) error {
	var err error
	*i, err = FamilyString(string(text))
	return err
}

const _LACPRateName = "slowfast"

var _LACPRateIndex = [...]uint8{0, 4, 8}

const _LACPRateLowerName = "slowfast"

func (i LACPRate) String() string {
	if i >= LACPRate(len(_LACPRateIndex)-1) {
		return fmt.Sprintf("LACPRate(%d)", i)
	}
	return _LACPRateName[_LACPRateIndex[i]:_LACPRateIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LACPRateNoOp() {
	var x [1]struct{}
	_ = x[LACPRateSlow-(0)]
	_ = x[LACPRateFast-(1)]
}

var _LACPRateValues = []LACPRate{LACPRateSlow, LACPRateFast}

var _LACPRateNameToValueMap = map[string]LACPRate{
	_LACPRateName[0:4]:      LACPRateSlow,
	_LACPRateLowerName[0:4]: LACPRateSlow,
	_LACPRateName[4:8]:      LACPRateFast,
	_LACPRateLowerName[4:8]: LACPRateFast,
}

var _LACPRateNames = []string{
	_LACPRateName[0:4],
	_LACPRateName[4:8],
}

// LACPRateString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LACPRateString(s string) (LACPRate, error) {
	if val, ok := _LACPRateNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LACPRateNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LACPRate values", s)
}

// LACPRateValues returns all values of the enum
func LACPRateValues() []LACPRate {
	return _LACPRateValues
}

// LACPRateStrings returns a slice of all String values of the enum
func LACPRateStrings() []string {
	strs := make([]string, len(_LACPRateNames))
	copy(strs, _LACPRateNames)
	return strs
}

// IsALACPRate returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LACPRate) IsALACPRate() bool {
	for _, v := range _LACPRateValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for LACPRate
func (i LACPRate) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for LACPRate
func (i *LACPRate) UnmarshalText(text []byte) error {
	var err error
	*i, err = LACPRateString(string(text))
	return err
}

const _LinkFlagName = "UPBROADCASTDEBUGLOOPBACKPOINTTOPOINTNOTRAILERSRUNNINGNOARPPROMISCALLMULTIMASTERSLAVEMULTICASTPORTSELAUTOMEDIADYNAMICLOWER_UPDORMANTECHO"
const _LinkFlagLowerName = "upbroadcastdebugloopbackpointtopointnotrailersrunningnoarppromiscallmultimasterslavemulticastportselautomediadynamiclower_updormantecho"

var _LinkFlagMap = map[LinkFlag]string{
	1:      _LinkFlagName[0:2],
	2:      _LinkFlagName[2:11],
	4:      _LinkFlagName[11:16],
	8:      _LinkFlagName[16:24],
	16:     _LinkFlagName[24:36],
	32:     _LinkFlagName[36:46],
	64:     _LinkFlagName[46:53],
	128:    _LinkFlagName[53:58],
	256:    _LinkFlagName[58:65],
	512:    _LinkFlagName[65:73],
	1024:   _LinkFlagName[73:79],
	2048:   _LinkFlagName[79:84],
	4096:   _LinkFlagName[84:93],
	8192:   _LinkFlagName[93:100],
	16384:  _LinkFlagName[100:109],
	32768:  _LinkFlagName[109:116],
	65536:  _LinkFlagName[116:124],
	131072: _LinkFlagName[124:131],
	262144: _LinkFlagName[131:135],
}

func (i LinkFlag) String() string {
	if str, ok := _LinkFlagMap[i]; ok {
		return str
	}
	return fmt.Sprintf("LinkFlag(%d)", i)
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LinkFlagNoOp() {
	var x [1]struct{}
	_ = x[LinkUp-(1)]
	_ = x[LinkBroadcast-(2)]
	_ = x[LinkDebug-(4)]
	_ = x[LinkLoopback-(8)]
	_ = x[LinkPointToPoint-(16)]
	_ = x[LinkNoTrailers-(32)]
	_ = x[LinkRunning-(64)]
	_ = x[LinkNoArp-(128)]
	_ = x[LinkPromisc-(256)]
	_ = x[LinkAllMulti-(512)]
	_ = x[LinkMaster-(1024)]
	_ = x[LinkSlave-(2048)]
	_ = x[LinkMulticase-(4096)]
	_ = x[LinkPortsel-(8192)]
	_ = x[LinKAutoMedia-(16384)]
	_ = x[LinkDynamic-(32768)]
	_ = x[LinkLowerUp-(65536)]
	_ = x[LinkDormant-(131072)]
	_ = x[LinkEcho-(262144)]
}

var _LinkFlagValues = []LinkFlag{LinkUp, LinkBroadcast, LinkDebug, LinkLoopback, LinkPointToPoint, LinkNoTrailers, LinkRunning, LinkNoArp, LinkPromisc, LinkAllMulti, LinkMaster, LinkSlave, LinkMulticase, LinkPortsel, LinKAutoMedia, LinkDynamic, LinkLowerUp, LinkDormant, LinkEcho}

var _LinkFlagNameToValueMap = map[string]LinkFlag{
	_LinkFlagName[0:2]:          LinkUp,
	_LinkFlagLowerName[0:2]:     LinkUp,
	_LinkFlagName[2:11]:         LinkBroadcast,
	_LinkFlagLowerName[2:11]:    LinkBroadcast,
	_LinkFlagName[11:16]:        LinkDebug,
	_LinkFlagLowerName[11:16]:   LinkDebug,
	_LinkFlagName[16:24]:        LinkLoopback,
	_LinkFlagLowerName[16:24]:   LinkLoopback,
	_LinkFlagName[24:36]:        LinkPointToPoint,
	_LinkFlagLowerName[24:36]:   LinkPointToPoint,
	_LinkFlagName[36:46]:        LinkNoTrailers,
	_LinkFlagLowerName[36:46]:   LinkNoTrailers,
	_LinkFlagName[46:53]:        LinkRunning,
	_LinkFlagLowerName[46:53]:   LinkRunning,
	_LinkFlagName[53:58]:        LinkNoArp,
	_LinkFlagLowerName[53:58]:   LinkNoArp,
	_LinkFlagName[58:65]:        LinkPromisc,
	_LinkFlagLowerName[58:65]:   LinkPromisc,
	_LinkFlagName[65:73]:        LinkAllMulti,
	_LinkFlagLowerName[65:73]:   LinkAllMulti,
	_LinkFlagName[73:79]:        LinkMaster,
	_LinkFlagLowerName[73:79]:   LinkMaster,
	_LinkFlagName[79:84]:        LinkSlave,
	_LinkFlagLowerName[79:84]:   LinkSlave,
	_LinkFlagName[84:93]:        LinkMulticase,
	_LinkFlagLowerName[84:93]:   LinkMulticase,
	_LinkFlagName[93:100]:       LinkPortsel,
	_LinkFlagLowerName[93:100]:  LinkPortsel,
	_LinkFlagName[100:109]:      LinKAutoMedia,
	_LinkFlagLowerName[100:109]: LinKAutoMedia,
	_LinkFlagName[109:116]:      LinkDynamic,
	_LinkFlagLowerName[109:116]: LinkDynamic,
	_LinkFlagName[116:124]:      LinkLowerUp,
	_LinkFlagLowerName[116:124]: LinkLowerUp,
	_LinkFlagName[124:131]:      LinkDormant,
	_LinkFlagLowerName[124:131]: LinkDormant,
	_LinkFlagName[131:135]:      LinkEcho,
	_LinkFlagLowerName[131:135]: LinkEcho,
}

var _LinkFlagNames = []string{
	_LinkFlagName[0:2],
	_LinkFlagName[2:11],
	_LinkFlagName[11:16],
	_LinkFlagName[16:24],
	_LinkFlagName[24:36],
	_LinkFlagName[36:46],
	_LinkFlagName[46:53],
	_LinkFlagName[53:58],
	_LinkFlagName[58:65],
	_LinkFlagName[65:73],
	_LinkFlagName[73:79],
	_LinkFlagName[79:84],
	_LinkFlagName[84:93],
	_LinkFlagName[93:100],
	_LinkFlagName[100:109],
	_LinkFlagName[109:116],
	_LinkFlagName[116:124],
	_LinkFlagName[124:131],
	_LinkFlagName[131:135],
}

// LinkFlagString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LinkFlagString(s string) (LinkFlag, error) {
	if val, ok := _LinkFlagNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LinkFlagNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LinkFlag values", s)
}

// LinkFlagValues returns all values of the enum
func LinkFlagValues() []LinkFlag {
	return _LinkFlagValues
}

// LinkFlagStrings returns a slice of all String values of the enum
func LinkFlagStrings() []string {
	strs := make([]string, len(_LinkFlagNames))
	copy(strs, _LinkFlagNames)
	return strs
}

// IsALinkFlag returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LinkFlag) IsALinkFlag() bool {
	_, ok := _LinkFlagMap[i]
	return ok
}

// MarshalText implements the encoding.TextMarshaler interface for LinkFlag
func (i LinkFlag) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for LinkFlag
func (i *LinkFlag) UnmarshalText(text []byte) error {
	var err error
	*i, err = LinkFlagString(string(text))
	return err
}

const _LinkTypeName = "netromethereetherax25pronetchaosieee802arcnetatalkdlciatmmetricomieee1394eui64infinibandslipcslipslip6cslip6rsrvdadaptrosex25hwx25canpppciscolapbddcmprawhdlcipiptunnel6fradskiploopbacklocaltlkfddibifsitip/ddpgrepimreghippiasheconetirdafcppfcalfcplfcfb_0fcfb_1fcfb_2fcfb_3fcfb_4fcfb_5fcfb_6fcfb_7fcfb_8fcfb_9fcfb_10fcfb_11fcfb_12trieee802.11ieee802.11_prismieee802.11_radiotapieee802.15.4ieee802.15.4_monitorphonetphonet_pipecaifip6grenetlink6lowpannohdrvoid"
const _LinkTypeLowerName = "netromethereetherax25pronetchaosieee802arcnetatalkdlciatmmetricomieee1394eui64infinibandslipcslipslip6cslip6rsrvdadaptrosex25hwx25canpppciscolapbddcmprawhdlcipiptunnel6fradskiploopbacklocaltlkfddibifsitip/ddpgrepimreghippiasheconetirdafcppfcalfcplfcfb_0fcfb_1fcfb_2fcfb_3fcfb_4fcfb_5fcfb_6fcfb_7fcfb_8fcfb_9fcfb_10fcfb_11fcfb_12trieee802.11ieee802.11_prismieee802.11_radiotapieee802.15.4ieee802.15.4_monitorphonetphonet_pipecaifip6grenetlink6lowpannohdrvoid"

var _LinkTypeMap = map[LinkType]string{
	0:     _LinkTypeName[0:6],
	1:     _LinkTypeName[6:11],
	2:     _LinkTypeName[11:17],
	3:     _LinkTypeName[17:21],
	4:     _LinkTypeName[21:27],
	5:     _LinkTypeName[27:32],
	6:     _LinkTypeName[32:39],
	7:     _LinkTypeName[39:45],
	8:     _LinkTypeName[45:50],
	15:    _LinkTypeName[50:54],
	19:    _LinkTypeName[54:57],
	23:    _LinkTypeName[57:65],
	24:    _LinkTypeName[65:73],
	27:    _LinkTypeName[73:78],
	32:    _LinkTypeName[78:88],
	256:   _LinkTypeName[88:92],
	257:   _LinkTypeName[92:97],
	258:   _LinkTypeName[97:102],
	259:   _LinkTypeName[102:108],
	260:   _LinkTypeName[108:113],
	264:   _LinkTypeName[113:118],
	270:   _LinkTypeName[118:122],
	271:   _LinkTypeName[122:125],
	272:   _LinkTypeName[125:130],
	280:   _LinkTypeName[130:133],
	512:   _LinkTypeName[133:136],
	513:   _LinkTypeName[136:141],
	516:   _LinkTypeName[141:145],
	517:   _LinkTypeName[145:150],
	518:   _LinkTypeName[150:157],
	768:   _LinkTypeName[157:161],
	769:   _LinkTypeName[161:168],
	770:   _LinkTypeName[168:172],
	771:   _LinkTypeName[172:176],
	772:   _LinkTypeName[176:184],
	773:   _LinkTypeName[184:192],
	774:   _LinkTypeName[192:196],
	775:   _LinkTypeName[196:199],
	776:   _LinkTypeName[199:202],
	777:   _LinkTypeName[202:208],
	778:   _LinkTypeName[208:211],
	779:   _LinkTypeName[211:217],
	780:   _LinkTypeName[217:222],
	781:   _LinkTypeName[222:225],
	782:   _LinkTypeName[225:231],
	783:   _LinkTypeName[231:235],
	784:   _LinkTypeName[235:239],
	785:   _LinkTypeName[239:243],
	786:   _LinkTypeName[243:247],
	787:   _LinkTypeName[247:253],
	788:   _LinkTypeName[253:259],
	789:   _LinkTypeName[259:265],
	790:   _LinkTypeName[265:271],
	791:   _LinkTypeName[271:277],
	792:   _LinkTypeName[277:283],
	793:   _LinkTypeName[283:289],
	794:   _LinkTypeName[289:295],
	795:   _LinkTypeName[295:301],
	796:   _LinkTypeName[301:307],
	797:   _LinkTypeName[307:314],
	798:   _LinkTypeName[314:321],
	799:   _LinkTypeName[321:328],
	800:   _LinkTypeName[328:330],
	801:   _LinkTypeName[330:340],
	802:   _LinkTypeName[340:356],
	803:   _LinkTypeName[356:375],
	804:   _LinkTypeName[375:387],
	805:   _LinkTypeName[387:407],
	820:   _LinkTypeName[407:413],
	821:   _LinkTypeName[413:424],
	822:   _LinkTypeName[424:428],
	823:   _LinkTypeName[428:434],
	824:   _LinkTypeName[434:441],
	825:   _LinkTypeName[441:448],
	65534: _LinkTypeName[448:453],
	65535: _LinkTypeName[453:457],
}

func (i LinkType) String() string {
	if str, ok := _LinkTypeMap[i]; ok {
		return str
	}
	return fmt.Sprintf("LinkType(%d)", i)
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LinkTypeNoOp() {
	var x [1]struct{}
	_ = x[LinkNetrom-(0)]
	_ = x[LinkEther-(1)]
	_ = x[LinkEether-(2)]
	_ = x[LinkAx25-(3)]
	_ = x[LinkPronet-(4)]
	_ = x[LinkChaos-(5)]
	_ = x[LinkIee802-(6)]
	_ = x[LinkArcnet-(7)]
	_ = x[LinkAtalk-(8)]
	_ = x[LinkDlci-(15)]
	_ = x[LinkAtm-(19)]
	_ = x[LinkMetricom-(23)]
	_ = x[LinkIeee1394-(24)]
	_ = x[LinkEui64-(27)]
	_ = x[LinkInfiniband-(32)]
	_ = x[LinkSlip-(256)]
	_ = x[LinkCslip-(257)]
	_ = x[LinkSlip6-(258)]
	_ = x[LinkCslip6-(259)]
	_ = x[LinkRsrvd-(260)]
	_ = x[LinkAdapt-(264)]
	_ = x[LinkRose-(270)]
	_ = x[LinkX25-(271)]
	_ = x[LinkHwx25-(272)]
	_ = x[LinkCan-(280)]
	_ = x[LinkPpp-(512)]
	_ = x[LinkCisco-(513)]
	_ = x[LinkLapb-(516)]
	_ = x[LinkDdcmp-(517)]
	_ = x[LinkRawhdlc-(518)]
	_ = x[LinkTunnel-(768)]
	_ = x[LinkTunnel6-(769)]
	_ = x[LinkFrad-(770)]
	_ = x[LinkSkip-(771)]
	_ = x[LinkLoopbck-(772)]
	_ = x[LinkLocaltlk-(773)]
	_ = x[LinkFddi-(774)]
	_ = x[LinkBif-(775)]
	_ = x[LinkSit-(776)]
	_ = x[LinkIpddp-(777)]
	_ = x[LinkIpgre-(778)]
	_ = x[LinkPimreg-(779)]
	_ = x[LinkHippi-(780)]
	_ = x[LinkAsh-(781)]
	_ = x[LinkEconet-(782)]
	_ = x[LinkIrda-(783)]
	_ = x[LinkFcpp-(784)]
	_ = x[LinkFcal-(785)]
	_ = x[LinkFcpl-(786)]
	_ = x[LinkFcfabric-(787)]
	_ = x[LinkFcfabric1-(788)]
	_ = x[LinkFcfabric2-(789)]
	_ = x[LinkFcfabric3-(790)]
	_ = x[LinkFcfabric4-(791)]
	_ = x[LinkFcfabric5-(792)]
	_ = x[LinkFcfabric6-(793)]
	_ = x[LinkFcfabric7-(794)]
	_ = x[LinkFcfabric8-(795)]
	_ = x[LinkFcfabric9-(796)]
	_ = x[LinkFcfabric10-(797)]
	_ = x[LinkFcfabric11-(798)]
	_ = x[LinkFcfabric12-(799)]
	_ = x[LinkIee802tr-(800)]
	_ = x[LinkIee80211-(801)]
	_ = x[LinkIee80211prism-(802)]
	_ = x[LinkIee80211Radiotap-(803)]
	_ = x[LinkIee8021154-(804)]
	_ = x[LinkIee8021154monitor-(805)]
	_ = x[LinkPhonet-(820)]
	_ = x[LinkPhonetpipe-(821)]
	_ = x[LinkCaif-(822)]
	_ = x[LinkIP6gre-(823)]
	_ = x[LinkNetlink-(824)]
	_ = x[Link6Lowpan-(825)]
	_ = x[LinkNone-(65534)]
	_ = x[LinkVoid-(65535)]
}

var _LinkTypeValues = []LinkType{LinkNetrom, LinkEther, LinkEether, LinkAx25, LinkPronet, LinkChaos, LinkIee802, LinkArcnet, LinkAtalk, LinkDlci, LinkAtm, LinkMetricom, LinkIeee1394, LinkEui64, LinkInfiniband, LinkSlip, LinkCslip, LinkSlip6, LinkCslip6, LinkRsrvd, LinkAdapt, LinkRose, LinkX25, LinkHwx25, LinkCan, LinkPpp, LinkCisco, LinkLapb, LinkDdcmp, LinkRawhdlc, LinkTunnel, LinkTunnel6, LinkFrad, LinkSkip, LinkLoopbck, LinkLocaltlk, LinkFddi, LinkBif, LinkSit, LinkIpddp, LinkIpgre, LinkPimreg, LinkHippi, LinkAsh, LinkEconet, LinkIrda, LinkFcpp, LinkFcal, LinkFcpl, LinkFcfabric, LinkFcfabric1, LinkFcfabric2, LinkFcfabric3, LinkFcfabric4, LinkFcfabric5, LinkFcfabric6, LinkFcfabric7, LinkFcfabric8, LinkFcfabric9, LinkFcfabric10, LinkFcfabric11, LinkFcfabric12, LinkIee802tr, LinkIee80211, LinkIee80211prism, LinkIee80211Radiotap, LinkIee8021154, LinkIee8021154monitor, LinkPhonet, LinkPhonetpipe, LinkCaif, LinkIP6gre, LinkNetlink, Link6Lowpan, LinkNone, LinkVoid}

var _LinkTypeNameToValueMap = map[string]LinkType{
	_LinkTypeName[0:6]:          LinkNetrom,
	_LinkTypeLowerName[0:6]:     LinkNetrom,
	_LinkTypeName[6:11]:         LinkEther,
	_LinkTypeLowerName[6:11]:    LinkEther,
	_LinkTypeName[11:17]:        LinkEether,
	_LinkTypeLowerName[11:17]:   LinkEether,
	_LinkTypeName[17:21]:        LinkAx25,
	_LinkTypeLowerName[17:21]:   LinkAx25,
	_LinkTypeName[21:27]:        LinkPronet,
	_LinkTypeLowerName[21:27]:   LinkPronet,
	_LinkTypeName[27:32]:        LinkChaos,
	_LinkTypeLowerName[27:32]:   LinkChaos,
	_LinkTypeName[32:39]:        LinkIee802,
	_LinkTypeLowerName[32:39]:   LinkIee802,
	_LinkTypeName[39:45]:        LinkArcnet,
	_LinkTypeLowerName[39:45]:   LinkArcnet,
	_LinkTypeName[45:50]:        LinkAtalk,
	_LinkTypeLowerName[45:50]:   LinkAtalk,
	_LinkTypeName[50:54]:        LinkDlci,
	_LinkTypeLowerName[50:54]:   LinkDlci,
	_LinkTypeName[54:57]:        LinkAtm,
	_LinkTypeLowerName[54:57]:   LinkAtm,
	_LinkTypeName[57:65]:        LinkMetricom,
	_LinkTypeLowerName[57:65]:   LinkMetricom,
	_LinkTypeName[65:73]:        LinkIeee1394,
	_LinkTypeLowerName[65:73]:   LinkIeee1394,
	_LinkTypeName[73:78]:        LinkEui64,
	_LinkTypeLowerName[73:78]:   LinkEui64,
	_LinkTypeName[78:88]:        LinkInfiniband,
	_LinkTypeLowerName[78:88]:   LinkInfiniband,
	_LinkTypeName[88:92]:        LinkSlip,
	_LinkTypeLowerName[88:92]:   LinkSlip,
	_LinkTypeName[92:97]:        LinkCslip,
	_LinkTypeLowerName[92:97]:   LinkCslip,
	_LinkTypeName[97:102]:       LinkSlip6,
	_LinkTypeLowerName[97:102]:  LinkSlip6,
	_LinkTypeName[102:108]:      LinkCslip6,
	_LinkTypeLowerName[102:108]: LinkCslip6,
	_LinkTypeName[108:113]:      LinkRsrvd,
	_LinkTypeLowerName[108:113]: LinkRsrvd,
	_LinkTypeName[113:118]:      LinkAdapt,
	_LinkTypeLowerName[113:118]: LinkAdapt,
	_LinkTypeName[118:122]:      LinkRose,
	_LinkTypeLowerName[118:122]: LinkRose,
	_LinkTypeName[122:125]:      LinkX25,
	_LinkTypeLowerName[122:125]: LinkX25,
	_LinkTypeName[125:130]:      LinkHwx25,
	_LinkTypeLowerName[125:130]: LinkHwx25,
	_LinkTypeName[130:133]:      LinkCan,
	_LinkTypeLowerName[130:133]: LinkCan,
	_LinkTypeName[133:136]:      LinkPpp,
	_LinkTypeLowerName[133:136]: LinkPpp,
	_LinkTypeName[136:141]:      LinkCisco,
	_LinkTypeLowerName[136:141]: LinkCisco,
	_LinkTypeName[141:145]:      LinkLapb,
	_LinkTypeLowerName[141:145]: LinkLapb,
	_LinkTypeName[145:150]:      LinkDdcmp,
	_LinkTypeLowerName[145:150]: LinkDdcmp,
	_LinkTypeName[150:157]:      LinkRawhdlc,
	_LinkTypeLowerName[150:157]: LinkRawhdlc,
	_LinkTypeName[157:161]:      LinkTunnel,
	_LinkTypeLowerName[157:161]: LinkTunnel,
	_LinkTypeName[161:168]:      LinkTunnel6,
	_LinkTypeLowerName[161:168]: LinkTunnel6,
	_LinkTypeName[168:172]:      LinkFrad,
	_LinkTypeLowerName[168:172]: LinkFrad,
	_LinkTypeName[172:176]:      LinkSkip,
	_LinkTypeLowerName[172:176]: LinkSkip,
	_LinkTypeName[176:184]:      LinkLoopbck,
	_LinkTypeLowerName[176:184]: LinkLoopbck,
	_LinkTypeName[184:192]:      LinkLocaltlk,
	_LinkTypeLowerName[184:192]: LinkLocaltlk,
	_LinkTypeName[192:196]:      LinkFddi,
	_LinkTypeLowerName[192:196]: LinkFddi,
	_LinkTypeName[196:199]:      LinkBif,
	_LinkTypeLowerName[196:199]: LinkBif,
	_LinkTypeName[199:202]:      LinkSit,
	_LinkTypeLowerName[199:202]: LinkSit,
	_LinkTypeName[202:208]:      LinkIpddp,
	_LinkTypeLowerName[202:208]: LinkIpddp,
	_LinkTypeName[208:211]:      LinkIpgre,
	_LinkTypeLowerName[208:211]: LinkIpgre,
	_LinkTypeName[211:217]:      LinkPimreg,
	_LinkTypeLowerName[211:217]: LinkPimreg,
	_LinkTypeName[217:222]:      LinkHippi,
	_LinkTypeLowerName[217:222]: LinkHippi,
	_LinkTypeName[222:225]:      LinkAsh,
	_LinkTypeLowerName[222:225]: LinkAsh,
	_LinkTypeName[225:231]:      LinkEconet,
	_LinkTypeLowerName[225:231]: LinkEconet,
	_LinkTypeName[231:235]:      LinkIrda,
	_LinkTypeLowerName[231:235]: LinkIrda,
	_LinkTypeName[235:239]:      LinkFcpp,
	_LinkTypeLowerName[235:239]: LinkFcpp,
	_LinkTypeName[239:243]:      LinkFcal,
	_LinkTypeLowerName[239:243]: LinkFcal,
	_LinkTypeName[243:247]:      LinkFcpl,
	_LinkTypeLowerName[243:247]: LinkFcpl,
	_LinkTypeName[247:253]:      LinkFcfabric,
	_LinkTypeLowerName[247:253]: LinkFcfabric,
	_LinkTypeName[253:259]:      LinkFcfabric1,
	_LinkTypeLowerName[253:259]: LinkFcfabric1,
	_LinkTypeName[259:265]:      LinkFcfabric2,
	_LinkTypeLowerName[259:265]: LinkFcfabric2,
	_LinkTypeName[265:271]:      LinkFcfabric3,
	_LinkTypeLowerName[265:271]: LinkFcfabric3,
	_LinkTypeName[271:277]:      LinkFcfabric4,
	_LinkTypeLowerName[271:277]: LinkFcfabric4,
	_LinkTypeName[277:283]:      LinkFcfabric5,
	_LinkTypeLowerName[277:283]: LinkFcfabric5,
	_LinkTypeName[283:289]:      LinkFcfabric6,
	_LinkTypeLowerName[283:289]: LinkFcfabric6,
	_LinkTypeName[289:295]:      LinkFcfabric7,
	_LinkTypeLowerName[289:295]: LinkFcfabric7,
	_LinkTypeName[295:301]:      LinkFcfabric8,
	_LinkTypeLowerName[295:301]: LinkFcfabric8,
	_LinkTypeName[301:307]:      LinkFcfabric9,
	_LinkTypeLowerName[301:307]: LinkFcfabric9,
	_LinkTypeName[307:314]:      LinkFcfabric10,
	_LinkTypeLowerName[307:314]: LinkFcfabric10,
	_LinkTypeName[314:321]:      LinkFcfabric11,
	_LinkTypeLowerName[314:321]: LinkFcfabric11,
	_LinkTypeName[321:328]:      LinkFcfabric12,
	_LinkTypeLowerName[321:328]: LinkFcfabric12,
	_LinkTypeName[328:330]:      LinkIee802tr,
	_LinkTypeLowerName[328:330]: LinkIee802tr,
	_LinkTypeName[330:340]:      LinkIee80211,
	_LinkTypeLowerName[330:340]: LinkIee80211,
	_LinkTypeName[340:356]:      LinkIee80211prism,
	_LinkTypeLowerName[340:356]: LinkIee80211prism,
	_LinkTypeName[356:375]:      LinkIee80211Radiotap,
	_LinkTypeLowerName[356:375]: LinkIee80211Radiotap,
	_LinkTypeName[375:387]:      LinkIee8021154,
	_LinkTypeLowerName[375:387]: LinkIee8021154,
	_LinkTypeName[387:407]:      LinkIee8021154monitor,
	_LinkTypeLowerName[387:407]: LinkIee8021154monitor,
	_LinkTypeName[407:413]:      LinkPhonet,
	_LinkTypeLowerName[407:413]: LinkPhonet,
	_LinkTypeName[413:424]:      LinkPhonetpipe,
	_LinkTypeLowerName[413:424]: LinkPhonetpipe,
	_LinkTypeName[424:428]:      LinkCaif,
	_LinkTypeLowerName[424:428]: LinkCaif,
	_LinkTypeName[428:434]:      LinkIP6gre,
	_LinkTypeLowerName[428:434]: LinkIP6gre,
	_LinkTypeName[434:441]:      LinkNetlink,
	_LinkTypeLowerName[434:441]: LinkNetlink,
	_LinkTypeName[441:448]:      Link6Lowpan,
	_LinkTypeLowerName[441:448]: Link6Lowpan,
	_LinkTypeName[448:453]:      LinkNone,
	_LinkTypeLowerName[448:453]: LinkNone,
	_LinkTypeName[453:457]:      LinkVoid,
	_LinkTypeLowerName[453:457]: LinkVoid,
}

var _LinkTypeNames = []string{
	_LinkTypeName[0:6],
	_LinkTypeName[6:11],
	_LinkTypeName[11:17],
	_LinkTypeName[17:21],
	_LinkTypeName[21:27],
	_LinkTypeName[27:32],
	_LinkTypeName[32:39],
	_LinkTypeName[39:45],
	_LinkTypeName[45:50],
	_LinkTypeName[50:54],
	_LinkTypeName[54:57],
	_LinkTypeName[57:65],
	_LinkTypeName[65:73],
	_LinkTypeName[73:78],
	_LinkTypeName[78:88],
	_LinkTypeName[88:92],
	_LinkTypeName[92:97],
	_LinkTypeName[97:102],
	_LinkTypeName[102:108],
	_LinkTypeName[108:113],
	_LinkTypeName[113:118],
	_LinkTypeName[118:122],
	_LinkTypeName[122:125],
	_LinkTypeName[125:130],
	_LinkTypeName[130:133],
	_LinkTypeName[133:136],
	_LinkTypeName[136:141],
	_LinkTypeName[141:145],
	_LinkTypeName[145:150],
	_LinkTypeName[150:157],
	_LinkTypeName[157:161],
	_LinkTypeName[161:168],
	_LinkTypeName[168:172],
	_LinkTypeName[172:176],
	_LinkTypeName[176:184],
	_LinkTypeName[184:192],
	_LinkTypeName[192:196],
	_LinkTypeName[196:199],
	_LinkTypeName[199:202],
	_LinkTypeName[202:208],
	_LinkTypeName[208:211],
	_LinkTypeName[211:217],
	_LinkTypeName[217:222],
	_LinkTypeName[222:225],
	_LinkTypeName[225:231],
	_LinkTypeName[231:235],
	_LinkTypeName[235:239],
	_LinkTypeName[239:243],
	_LinkTypeName[243:247],
	_LinkTypeName[247:253],
	_LinkTypeName[253:259],
	_LinkTypeName[259:265],
	_LinkTypeName[265:271],
	_LinkTypeName[271:277],
	_LinkTypeName[277:283],
	_LinkTypeName[283:289],
	_LinkTypeName[289:295],
	_LinkTypeName[295:301],
	_LinkTypeName[301:307],
	_LinkTypeName[307:314],
	_LinkTypeName[314:321],
	_LinkTypeName[321:328],
	_LinkTypeName[328:330],
	_LinkTypeName[330:340],
	_LinkTypeName[340:356],
	_LinkTypeName[356:375],
	_LinkTypeName[375:387],
	_LinkTypeName[387:407],
	_LinkTypeName[407:413],
	_LinkTypeName[413:424],
	_LinkTypeName[424:428],
	_LinkTypeName[428:434],
	_LinkTypeName[434:441],
	_LinkTypeName[441:448],
	_LinkTypeName[448:453],
	_LinkTypeName[453:457],
}

// LinkTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LinkTypeString(s string) (LinkType, error) {
	if val, ok := _LinkTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LinkTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LinkType values", s)
}

// LinkTypeValues returns all values of the enum
func LinkTypeValues() []LinkType {
	return _LinkTypeValues
}

// LinkTypeStrings returns a slice of all String values of the enum
func LinkTypeStrings() []string {
	strs := make([]string, len(_LinkTypeNames))
	copy(strs, _LinkTypeNames)
	return strs
}

// IsALinkType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LinkType) IsALinkType() bool {
	_, ok := _LinkTypeMap[i]
	return ok
}

// MarshalText implements the encoding.TextMarshaler interface for LinkType
func (i LinkType) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for LinkType
func (i *LinkType) UnmarshalText(text []byte) error {
	var err error
	*i, err = LinkTypeString(string(text))
	return err
}

const _MatchOperatorName = "==!="

var _MatchOperatorIndex = [...]uint8{0, 2, 4}

const _MatchOperatorLowerName = "==!="

func (i MatchOperator) String() string {
	if i < 0 || i >= MatchOperator(len(_MatchOperatorIndex)-1) {
		return fmt.Sprintf("MatchOperator(%d)", i)
	}
	return _MatchOperatorName[_MatchOperatorIndex[i]:_MatchOperatorIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _MatchOperatorNoOp() {
	var x [1]struct{}
	_ = x[OperatorEqual-(0)]
	_ = x[OperatorNotEqual-(1)]
}

var _MatchOperatorValues = []MatchOperator{OperatorEqual, OperatorNotEqual}

var _MatchOperatorNameToValueMap = map[string]MatchOperator{
	_MatchOperatorName[0:2]:      OperatorEqual,
	_MatchOperatorLowerName[0:2]: OperatorEqual,
	_MatchOperatorName[2:4]:      OperatorNotEqual,
	_MatchOperatorLowerName[2:4]: OperatorNotEqual,
}

var _MatchOperatorNames = []string{
	_MatchOperatorName[0:2],
	_MatchOperatorName[2:4],
}

// MatchOperatorString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func MatchOperatorString(s string) (MatchOperator, error) {
	if val, ok := _MatchOperatorNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _MatchOperatorNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to MatchOperator values", s)
}

// MatchOperatorValues returns all values of the enum
func MatchOperatorValues() []MatchOperator {
	return _MatchOperatorValues
}

// MatchOperatorStrings returns a slice of all String values of the enum
func MatchOperatorStrings() []string {
	strs := make([]string, len(_MatchOperatorNames))
	copy(strs, _MatchOperatorNames)
	return strs
}

// IsAMatchOperator returns "true" if the value is listed in the enum definition. "false" otherwise
func (i MatchOperator) IsAMatchOperator() bool {
	for _, v := range _MatchOperatorValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for MatchOperator
func (i MatchOperator) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for MatchOperator
func (i *MatchOperator) UnmarshalText(text []byte) error {
	var err error
	*i, err = MatchOperatorString(string(text))
	return err
}

const _NfTablesChainHookName = "preroutinginputforwardoutputpostrouting"

var _NfTablesChainHookIndex = [...]uint8{0, 10, 15, 22, 28, 39}

const _NfTablesChainHookLowerName = "preroutinginputforwardoutputpostrouting"

func (i NfTablesChainHook) String() string {
	if i >= NfTablesChainHook(len(_NfTablesChainHookIndex)-1) {
		return fmt.Sprintf("NfTablesChainHook(%d)", i)
	}
	return _NfTablesChainHookName[_NfTablesChainHookIndex[i]:_NfTablesChainHookIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _NfTablesChainHookNoOp() {
	var x [1]struct{}
	_ = x[ChainHookPrerouting-(0)]
	_ = x[ChainHookInput-(1)]
	_ = x[ChainHookForward-(2)]
	_ = x[ChainHookOutput-(3)]
	_ = x[ChainHookPostrouting-(4)]
}

var _NfTablesChainHookValues = []NfTablesChainHook{ChainHookPrerouting, ChainHookInput, ChainHookForward, ChainHookOutput, ChainHookPostrouting}

var _NfTablesChainHookNameToValueMap = map[string]NfTablesChainHook{
	_NfTablesChainHookName[0:10]:       ChainHookPrerouting,
	_NfTablesChainHookLowerName[0:10]:  ChainHookPrerouting,
	_NfTablesChainHookName[10:15]:      ChainHookInput,
	_NfTablesChainHookLowerName[10:15]: ChainHookInput,
	_NfTablesChainHookName[15:22]:      ChainHookForward,
	_NfTablesChainHookLowerName[15:22]: ChainHookForward,
	_NfTablesChainHookName[22:28]:      ChainHookOutput,
	_NfTablesChainHookLowerName[22:28]: ChainHookOutput,
	_NfTablesChainHookName[28:39]:      ChainHookPostrouting,
	_NfTablesChainHookLowerName[28:39]: ChainHookPostrouting,
}

var _NfTablesChainHookNames = []string{
	_NfTablesChainHookName[0:10],
	_NfTablesChainHookName[10:15],
	_NfTablesChainHookName[15:22],
	_NfTablesChainHookName[22:28],
	_NfTablesChainHookName[28:39],
}

// NfTablesChainHookString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func NfTablesChainHookString(s string) (NfTablesChainHook, error) {
	if val, ok := _NfTablesChainHookNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _NfTablesChainHookNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to NfTablesChainHook values", s)
}

// NfTablesChainHookValues returns all values of the enum
func NfTablesChainHookValues() []NfTablesChainHook {
	return _NfTablesChainHookValues
}

// NfTablesChainHookStrings returns a slice of all String values of the enum
func NfTablesChainHookStrings() []string {
	strs := make([]string, len(_NfTablesChainHookNames))
	copy(strs, _NfTablesChainHookNames)
	return strs
}

// IsANfTablesChainHook returns "true" if the value is listed in the enum definition. "false" otherwise
func (i NfTablesChainHook) IsANfTablesChainHook() bool {
	for _, v := range _NfTablesChainHookValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for NfTablesChainHook
func (i NfTablesChainHook) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for NfTablesChainHook
func (i *NfTablesChainHook) UnmarshalText(text []byte) error {
	var err error
	*i, err = NfTablesChainHookString(string(text))
	return err
}

const _NfTablesChainPriorityName = "firstconntrack-defragrawselinux-firstconntrackmanglenat-destfiltersecuritynat-sourceselinux-lastconntrack-helperlast"
const _NfTablesChainPriorityLowerName = "firstconntrack-defragrawselinux-firstconntrackmanglenat-destfiltersecuritynat-sourceselinux-lastconntrack-helperlast"

var _NfTablesChainPriorityMap = map[NfTablesChainPriority]string{
	-2147483648: _NfTablesChainPriorityName[0:5],
	-400:        _NfTablesChainPriorityName[5:21],
	-300:        _NfTablesChainPriorityName[21:24],
	-225:        _NfTablesChainPriorityName[24:37],
	-200:        _NfTablesChainPriorityName[37:46],
	-150:        _NfTablesChainPriorityName[46:52],
	-100:        _NfTablesChainPriorityName[52:60],
	0:           _NfTablesChainPriorityName[60:66],
	50:          _NfTablesChainPriorityName[66:74],
	100:         _NfTablesChainPriorityName[74:84],
	225:         _NfTablesChainPriorityName[84:96],
	300:         _NfTablesChainPriorityName[96:112],
	2147483647:  _NfTablesChainPriorityName[112:116],
}

func (i NfTablesChainPriority) String() string {
	if str, ok := _NfTablesChainPriorityMap[i]; ok {
		return str
	}
	return fmt.Sprintf("NfTablesChainPriority(%d)", i)
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _NfTablesChainPriorityNoOp() {
	var x [1]struct{}
	_ = x[ChainPriorityFirst-(-2147483648)]
	_ = x[ChainPriorityConntrackDefrag-(-400)]
	_ = x[ChainPriorityRaw-(-300)]
	_ = x[ChainPrioritySELinuxFirst-(-225)]
	_ = x[ChainPriorityConntrack-(-200)]
	_ = x[ChainPriorityMangle-(-150)]
	_ = x[ChainPriorityNATDest-(-100)]
	_ = x[ChainPriorityFilter-(0)]
	_ = x[ChainPrioritySecurity-(50)]
	_ = x[ChainPriorityNATSource-(100)]
	_ = x[ChainPrioritySELinuxLast-(225)]
	_ = x[ChainPriorityConntrackHelper-(300)]
	_ = x[ChainPriorityLast-(2147483647)]
}

var _NfTablesChainPriorityValues = []NfTablesChainPriority{ChainPriorityFirst, ChainPriorityConntrackDefrag, ChainPriorityRaw, ChainPrioritySELinuxFirst, ChainPriorityConntrack, ChainPriorityMangle, ChainPriorityNATDest, ChainPriorityFilter, ChainPrioritySecurity, ChainPriorityNATSource, ChainPrioritySELinuxLast, ChainPriorityConntrackHelper, ChainPriorityLast}

var _NfTablesChainPriorityNameToValueMap = map[string]NfTablesChainPriority{
	_NfTablesChainPriorityName[0:5]:          ChainPriorityFirst,
	_NfTablesChainPriorityLowerName[0:5]:     ChainPriorityFirst,
	_NfTablesChainPriorityName[5:21]:         ChainPriorityConntrackDefrag,
	_NfTablesChainPriorityLowerName[5:21]:    ChainPriorityConntrackDefrag,
	_NfTablesChainPriorityName[21:24]:        ChainPriorityRaw,
	_NfTablesChainPriorityLowerName[21:24]:   ChainPriorityRaw,
	_NfTablesChainPriorityName[24:37]:        ChainPrioritySELinuxFirst,
	_NfTablesChainPriorityLowerName[24:37]:   ChainPrioritySELinuxFirst,
	_NfTablesChainPriorityName[37:46]:        ChainPriorityConntrack,
	_NfTablesChainPriorityLowerName[37:46]:   ChainPriorityConntrack,
	_NfTablesChainPriorityName[46:52]:        ChainPriorityMangle,
	_NfTablesChainPriorityLowerName[46:52]:   ChainPriorityMangle,
	_NfTablesChainPriorityName[52:60]:        ChainPriorityNATDest,
	_NfTablesChainPriorityLowerName[52:60]:   ChainPriorityNATDest,
	_NfTablesChainPriorityName[60:66]:        ChainPriorityFilter,
	_NfTablesChainPriorityLowerName[60:66]:   ChainPriorityFilter,
	_NfTablesChainPriorityName[66:74]:        ChainPrioritySecurity,
	_NfTablesChainPriorityLowerName[66:74]:   ChainPrioritySecurity,
	_NfTablesChainPriorityName[74:84]:        ChainPriorityNATSource,
	_NfTablesChainPriorityLowerName[74:84]:   ChainPriorityNATSource,
	_NfTablesChainPriorityName[84:96]:        ChainPrioritySELinuxLast,
	_NfTablesChainPriorityLowerName[84:96]:   ChainPrioritySELinuxLast,
	_NfTablesChainPriorityName[96:112]:       ChainPriorityConntrackHelper,
	_NfTablesChainPriorityLowerName[96:112]:  ChainPriorityConntrackHelper,
	_NfTablesChainPriorityName[112:116]:      ChainPriorityLast,
	_NfTablesChainPriorityLowerName[112:116]: ChainPriorityLast,
}

var _NfTablesChainPriorityNames = []string{
	_NfTablesChainPriorityName[0:5],
	_NfTablesChainPriorityName[5:21],
	_NfTablesChainPriorityName[21:24],
	_NfTablesChainPriorityName[24:37],
	_NfTablesChainPriorityName[37:46],
	_NfTablesChainPriorityName[46:52],
	_NfTablesChainPriorityName[52:60],
	_NfTablesChainPriorityName[60:66],
	_NfTablesChainPriorityName[66:74],
	_NfTablesChainPriorityName[74:84],
	_NfTablesChainPriorityName[84:96],
	_NfTablesChainPriorityName[96:112],
	_NfTablesChainPriorityName[112:116],
}

// NfTablesChainPriorityString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func NfTablesChainPriorityString(s string) (NfTablesChainPriority, error) {
	if val, ok := _NfTablesChainPriorityNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _NfTablesChainPriorityNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to NfTablesChainPriority values", s)
}

// NfTablesChainPriorityValues returns all values of the enum
func NfTablesChainPriorityValues() []NfTablesChainPriority {
	return _NfTablesChainPriorityValues
}

// NfTablesChainPriorityStrings returns a slice of all String values of the enum
func NfTablesChainPriorityStrings() []string {
	strs := make([]string, len(_NfTablesChainPriorityNames))
	copy(strs, _NfTablesChainPriorityNames)
	return strs
}

// IsANfTablesChainPriority returns "true" if the value is listed in the enum definition. "false" otherwise
func (i NfTablesChainPriority) IsANfTablesChainPriority() bool {
	_, ok := _NfTablesChainPriorityMap[i]
	return ok
}

// MarshalText implements the encoding.TextMarshaler interface for NfTablesChainPriority
func (i NfTablesChainPriority) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for NfTablesChainPriority
func (i *NfTablesChainPriority) UnmarshalText(text []byte) error {
	var err error
	*i, err = NfTablesChainPriorityString(string(text))
	return err
}

const _NfTablesVerdictName = "dropaccept"

var _NfTablesVerdictIndex = [...]uint8{0, 4, 10}

const _NfTablesVerdictLowerName = "dropaccept"

func (i NfTablesVerdict) String() string {
	if i < 0 || i >= NfTablesVerdict(len(_NfTablesVerdictIndex)-1) {
		return fmt.Sprintf("NfTablesVerdict(%d)", i)
	}
	return _NfTablesVerdictName[_NfTablesVerdictIndex[i]:_NfTablesVerdictIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _NfTablesVerdictNoOp() {
	var x [1]struct{}
	_ = x[VerdictDrop-(0)]
	_ = x[VerdictAccept-(1)]
}

var _NfTablesVerdictValues = []NfTablesVerdict{VerdictDrop, VerdictAccept}

var _NfTablesVerdictNameToValueMap = map[string]NfTablesVerdict{
	_NfTablesVerdictName[0:4]:       VerdictDrop,
	_NfTablesVerdictLowerName[0:4]:  VerdictDrop,
	_NfTablesVerdictName[4:10]:      VerdictAccept,
	_NfTablesVerdictLowerName[4:10]: VerdictAccept,
}

var _NfTablesVerdictNames = []string{
	_NfTablesVerdictName[0:4],
	_NfTablesVerdictName[4:10],
}

// NfTablesVerdictString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func NfTablesVerdictString(s string) (NfTablesVerdict, error) {
	if val, ok := _NfTablesVerdictNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _NfTablesVerdictNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to NfTablesVerdict values", s)
}

// NfTablesVerdictValues returns all values of the enum
func NfTablesVerdictValues() []NfTablesVerdict {
	return _NfTablesVerdictValues
}

// NfTablesVerdictStrings returns a slice of all String values of the enum
func NfTablesVerdictStrings() []string {
	strs := make([]string, len(_NfTablesVerdictNames))
	copy(strs, _NfTablesVerdictNames)
	return strs
}

// IsANfTablesVerdict returns "true" if the value is listed in the enum definition. "false" otherwise
func (i NfTablesVerdict) IsANfTablesVerdict() bool {
	for _, v := range _NfTablesVerdictValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for NfTablesVerdict
func (i NfTablesVerdict) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for NfTablesVerdict
func (i *NfTablesVerdict) UnmarshalText(text []byte) error {
	var err error
	*i, err = NfTablesVerdictString(string(text))
	return err
}

const _OperationalStateName = "unknownnotPresentdownlowerLayerDowntestingdormantup"

var _OperationalStateIndex = [...]uint8{0, 7, 17, 21, 35, 42, 49, 51}

const _OperationalStateLowerName = "unknownnotpresentdownlowerlayerdowntestingdormantup"

func (i OperationalState) String() string {
	if i >= OperationalState(len(_OperationalStateIndex)-1) {
		return fmt.Sprintf("OperationalState(%d)", i)
	}
	return _OperationalStateName[_OperationalStateIndex[i]:_OperationalStateIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _OperationalStateNoOp() {
	var x [1]struct{}
	_ = x[OperStateUnknown-(0)]
	_ = x[OperStateNotPresent-(1)]
	_ = x[OperStateDown-(2)]
	_ = x[OperStateLowerLayerDown-(3)]
	_ = x[OperStateTesting-(4)]
	_ = x[OperStateDormant-(5)]
	_ = x[OperStateUp-(6)]
}

var _OperationalStateValues = []OperationalState{OperStateUnknown, OperStateNotPresent, OperStateDown, OperStateLowerLayerDown, OperStateTesting, OperStateDormant, OperStateUp}

var _OperationalStateNameToValueMap = map[string]OperationalState{
	_OperationalStateName[0:7]:        OperStateUnknown,
	_OperationalStateLowerName[0:7]:   OperStateUnknown,
	_OperationalStateName[7:17]:       OperStateNotPresent,
	_OperationalStateLowerName[7:17]:  OperStateNotPresent,
	_OperationalStateName[17:21]:      OperStateDown,
	_OperationalStateLowerName[17:21]: OperStateDown,
	_OperationalStateName[21:35]:      OperStateLowerLayerDown,
	_OperationalStateLowerName[21:35]: OperStateLowerLayerDown,
	_OperationalStateName[35:42]:      OperStateTesting,
	_OperationalStateLowerName[35:42]: OperStateTesting,
	_OperationalStateName[42:49]:      OperStateDormant,
	_OperationalStateLowerName[42:49]: OperStateDormant,
	_OperationalStateName[49:51]:      OperStateUp,
	_OperationalStateLowerName[49:51]: OperStateUp,
}

var _OperationalStateNames = []string{
	_OperationalStateName[0:7],
	_OperationalStateName[7:17],
	_OperationalStateName[17:21],
	_OperationalStateName[21:35],
	_OperationalStateName[35:42],
	_OperationalStateName[42:49],
	_OperationalStateName[49:51],
}

// OperationalStateString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func OperationalStateString(s string) (OperationalState, error) {
	if val, ok := _OperationalStateNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _OperationalStateNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to OperationalState values", s)
}

// OperationalStateValues returns all values of the enum
func OperationalStateValues() []OperationalState {
	return _OperationalStateValues
}

// OperationalStateStrings returns a slice of all String values of the enum
func OperationalStateStrings() []string {
	strs := make([]string, len(_OperationalStateNames))
	copy(strs, _OperationalStateNames)
	return strs
}

// IsAOperationalState returns "true" if the value is listed in the enum definition. "false" otherwise
func (i OperationalState) IsAOperationalState() bool {
	for _, v := range _OperationalStateValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for OperationalState
func (i OperationalState) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for OperationalState
func (i *OperationalState) UnmarshalText(text []byte) error {
	var err error
	*i, err = OperationalStateString(string(text))
	return err
}

const (
	_PortName_0      = "TwistedPairAUIMIIBNCDirectAttach"
	_PortLowerName_0 = "twistedpairauimiibncdirectattach"
	_PortName_1      = "None"
	_PortLowerName_1 = "none"
	_PortName_2      = "Other"
	_PortLowerName_2 = "other"
)

var (
	_PortIndex_0 = [...]uint8{0, 11, 14, 17, 17, 20, 32}
	_PortIndex_1 = [...]uint8{0, 4}
	_PortIndex_2 = [...]uint8{0, 5}
)

func (i Port) String() string {
	switch {
	case 0 <= i && i <= 5:
		return _PortName_0[_PortIndex_0[i]:_PortIndex_0[i+1]]
	case i == 239:
		return _PortName_1
	case i == 255:
		return _PortName_2
	default:
		return fmt.Sprintf("Port(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _PortNoOp() {
	var x [1]struct{}
	_ = x[TwistedPair-(0)]
	_ = x[AUI-(1)]
	_ = x[MII-(2)]
	_ = x[Fibre-(3)]
	_ = x[BNC-(4)]
	_ = x[DirectAttach-(5)]
	_ = x[None-(239)]
	_ = x[Other-(255)]
}

var _PortValues = []Port{TwistedPair, AUI, MII, Fibre, BNC, DirectAttach, None, Other}

var _PortNameToValueMap = map[string]Port{
	_PortName_0[0:11]:       TwistedPair,
	_PortLowerName_0[0:11]:  TwistedPair,
	_PortName_0[11:14]:      AUI,
	_PortLowerName_0[11:14]: AUI,
	_PortName_0[14:17]:      MII,
	_PortLowerName_0[14:17]: MII,
	_PortName_0[17:17]:      Fibre,
	_PortLowerName_0[17:17]: Fibre,
	_PortName_0[17:20]:      BNC,
	_PortLowerName_0[17:20]: BNC,
	_PortName_0[20:32]:      DirectAttach,
	_PortLowerName_0[20:32]: DirectAttach,
	_PortName_1[0:4]:        None,
	_PortLowerName_1[0:4]:   None,
	_PortName_2[0:5]:        Other,
	_PortLowerName_2[0:5]:   Other,
}

var _PortNames = []string{
	_PortName_0[0:11],
	_PortName_0[11:14],
	_PortName_0[14:17],
	_PortName_0[17:17],
	_PortName_0[17:20],
	_PortName_0[20:32],
	_PortName_1[0:4],
	_PortName_2[0:5],
}

// PortString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func PortString(s string) (Port, error) {
	if val, ok := _PortNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _PortNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Port values", s)
}

// PortValues returns all values of the enum
func PortValues() []Port {
	return _PortValues
}

// PortStrings returns a slice of all String values of the enum
func PortStrings() []string {
	strs := make([]string, len(_PortNames))
	copy(strs, _PortNames)
	return strs
}

// IsAPort returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Port) IsAPort() bool {
	for _, v := range _PortValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for Port
func (i Port) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Port
func (i *Port) UnmarshalText(text []byte) error {
	var err error
	*i, err = PortString(string(text))
	return err
}

const _PrimaryReselectName = "alwaysbetterfailure"

var _PrimaryReselectIndex = [...]uint8{0, 6, 12, 19}

const _PrimaryReselectLowerName = "alwaysbetterfailure"

func (i PrimaryReselect) String() string {
	if i >= PrimaryReselect(len(_PrimaryReselectIndex)-1) {
		return fmt.Sprintf("PrimaryReselect(%d)", i)
	}
	return _PrimaryReselectName[_PrimaryReselectIndex[i]:_PrimaryReselectIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _PrimaryReselectNoOp() {
	var x [1]struct{}
	_ = x[PrimaryReselectAlways-(0)]
	_ = x[PrimaryReselectBetter-(1)]
	_ = x[PrimaryReselectFailure-(2)]
}

var _PrimaryReselectValues = []PrimaryReselect{PrimaryReselectAlways, PrimaryReselectBetter, PrimaryReselectFailure}

var _PrimaryReselectNameToValueMap = map[string]PrimaryReselect{
	_PrimaryReselectName[0:6]:        PrimaryReselectAlways,
	_PrimaryReselectLowerName[0:6]:   PrimaryReselectAlways,
	_PrimaryReselectName[6:12]:       PrimaryReselectBetter,
	_PrimaryReselectLowerName[6:12]:  PrimaryReselectBetter,
	_PrimaryReselectName[12:19]:      PrimaryReselectFailure,
	_PrimaryReselectLowerName[12:19]: PrimaryReselectFailure,
}

var _PrimaryReselectNames = []string{
	_PrimaryReselectName[0:6],
	_PrimaryReselectName[6:12],
	_PrimaryReselectName[12:19],
}

// PrimaryReselectString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func PrimaryReselectString(s string) (PrimaryReselect, error) {
	if val, ok := _PrimaryReselectNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _PrimaryReselectNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to PrimaryReselect values", s)
}

// PrimaryReselectValues returns all values of the enum
func PrimaryReselectValues() []PrimaryReselect {
	return _PrimaryReselectValues
}

// PrimaryReselectStrings returns a slice of all String values of the enum
func PrimaryReselectStrings() []string {
	strs := make([]string, len(_PrimaryReselectNames))
	copy(strs, _PrimaryReselectNames)
	return strs
}

// IsAPrimaryReselect returns "true" if the value is listed in the enum definition. "false" otherwise
func (i PrimaryReselect) IsAPrimaryReselect() bool {
	for _, v := range _PrimaryReselectValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for PrimaryReselect
func (i PrimaryReselect) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for PrimaryReselect
func (i *PrimaryReselect) UnmarshalText(text []byte) error {
	var err error
	*i, err = PrimaryReselectString(string(text))
	return err
}

const (
	_ProtocolName_0      = "icmp"
	_ProtocolLowerName_0 = "icmp"
	_ProtocolName_1      = "tcp"
	_ProtocolLowerName_1 = "tcp"
	_ProtocolName_2      = "udp"
	_ProtocolLowerName_2 = "udp"
	_ProtocolName_3      = "icmpv6"
	_ProtocolLowerName_3 = "icmpv6"
)

var (
	_ProtocolIndex_0 = [...]uint8{0, 4}
	_ProtocolIndex_1 = [...]uint8{0, 3}
	_ProtocolIndex_2 = [...]uint8{0, 3}
	_ProtocolIndex_3 = [...]uint8{0, 6}
)

func (i Protocol) String() string {
	switch {
	case i == 1:
		return _ProtocolName_0
	case i == 6:
		return _ProtocolName_1
	case i == 17:
		return _ProtocolName_2
	case i == 58:
		return _ProtocolName_3
	default:
		return fmt.Sprintf("Protocol(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _ProtocolNoOp() {
	var x [1]struct{}
	_ = x[ProtocolICMP-(1)]
	_ = x[ProtocolTCP-(6)]
	_ = x[ProtocolUDP-(17)]
	_ = x[ProtocolICMPv6-(58)]
}

var _ProtocolValues = []Protocol{ProtocolICMP, ProtocolTCP, ProtocolUDP, ProtocolICMPv6}

var _ProtocolNameToValueMap = map[string]Protocol{
	_ProtocolName_0[0:4]:      ProtocolICMP,
	_ProtocolLowerName_0[0:4]: ProtocolICMP,
	_ProtocolName_1[0:3]:      ProtocolTCP,
	_ProtocolLowerName_1[0:3]: ProtocolTCP,
	_ProtocolName_2[0:3]:      ProtocolUDP,
	_ProtocolLowerName_2[0:3]: ProtocolUDP,
	_ProtocolName_3[0:6]:      ProtocolICMPv6,
	_ProtocolLowerName_3[0:6]: ProtocolICMPv6,
}

var _ProtocolNames = []string{
	_ProtocolName_0[0:4],
	_ProtocolName_1[0:3],
	_ProtocolName_2[0:3],
	_ProtocolName_3[0:6],
}

// ProtocolString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func ProtocolString(s string) (Protocol, error) {
	if val, ok := _ProtocolNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _ProtocolNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Protocol values", s)
}

// ProtocolValues returns all values of the enum
func ProtocolValues() []Protocol {
	return _ProtocolValues
}

// ProtocolStrings returns a slice of all String values of the enum
func ProtocolStrings() []string {
	strs := make([]string, len(_ProtocolNames))
	copy(strs, _ProtocolNames)
	return strs
}

// IsAProtocol returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Protocol) IsAProtocol() bool {
	for _, v := range _ProtocolValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for Protocol
func (i Protocol) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Protocol
func (i *Protocol) UnmarshalText(text []byte) error {
	var err error
	*i, err = ProtocolString(string(text))
	return err
}

const (
	_RouteFlagName_0      = "notify"
	_RouteFlagLowerName_0 = "notify"
	_RouteFlagName_1      = "cloned"
	_RouteFlagLowerName_1 = "cloned"
	_RouteFlagName_2      = "equalize"
	_RouteFlagLowerName_2 = "equalize"
	_RouteFlagName_3      = "prefix"
	_RouteFlagLowerName_3 = "prefix"
	_RouteFlagName_4      = "lookup_table"
	_RouteFlagLowerName_4 = "lookup_table"
	_RouteFlagName_5      = "fib_match"
	_RouteFlagLowerName_5 = "fib_match"
	_RouteFlagName_6      = "offload"
	_RouteFlagLowerName_6 = "offload"
	_RouteFlagName_7      = "trap"
	_RouteFlagLowerName_7 = "trap"
)

var (
	_RouteFlagIndex_0 = [...]uint8{0, 6}
	_RouteFlagIndex_1 = [...]uint8{0, 6}
	_RouteFlagIndex_2 = [...]uint8{0, 8}
	_RouteFlagIndex_3 = [...]uint8{0, 6}
	_RouteFlagIndex_4 = [...]uint8{0, 12}
	_RouteFlagIndex_5 = [...]uint8{0, 9}
	_RouteFlagIndex_6 = [...]uint8{0, 7}
	_RouteFlagIndex_7 = [...]uint8{0, 4}
)

func (i RouteFlag) String() string {
	switch {
	case i == 256:
		return _RouteFlagName_0
	case i == 512:
		return _RouteFlagName_1
	case i == 1024:
		return _RouteFlagName_2
	case i == 2048:
		return _RouteFlagName_3
	case i == 4096:
		return _RouteFlagName_4
	case i == 8192:
		return _RouteFlagName_5
	case i == 16384:
		return _RouteFlagName_6
	case i == 32768:
		return _RouteFlagName_7
	default:
		return fmt.Sprintf("RouteFlag(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _RouteFlagNoOp() {
	var x [1]struct{}
	_ = x[RouteNotify-(256)]
	_ = x[RouteCloned-(512)]
	_ = x[RouteEqualize-(1024)]
	_ = x[RoutePrefix-(2048)]
	_ = x[RouteLookupTable-(4096)]
	_ = x[RouteFIBMatch-(8192)]
	_ = x[RouteOffload-(16384)]
	_ = x[RouteTrap-(32768)]
}

var _RouteFlagValues = []RouteFlag{RouteNotify, RouteCloned, RouteEqualize, RoutePrefix, RouteLookupTable, RouteFIBMatch, RouteOffload, RouteTrap}

var _RouteFlagNameToValueMap = map[string]RouteFlag{
	_RouteFlagName_0[0:6]:       RouteNotify,
	_RouteFlagLowerName_0[0:6]:  RouteNotify,
	_RouteFlagName_1[0:6]:       RouteCloned,
	_RouteFlagLowerName_1[0:6]:  RouteCloned,
	_RouteFlagName_2[0:8]:       RouteEqualize,
	_RouteFlagLowerName_2[0:8]:  RouteEqualize,
	_RouteFlagName_3[0:6]:       RoutePrefix,
	_RouteFlagLowerName_3[0:6]:  RoutePrefix,
	_RouteFlagName_4[0:12]:      RouteLookupTable,
	_RouteFlagLowerName_4[0:12]: RouteLookupTable,
	_RouteFlagName_5[0:9]:       RouteFIBMatch,
	_RouteFlagLowerName_5[0:9]:  RouteFIBMatch,
	_RouteFlagName_6[0:7]:       RouteOffload,
	_RouteFlagLowerName_6[0:7]:  RouteOffload,
	_RouteFlagName_7[0:4]:       RouteTrap,
	_RouteFlagLowerName_7[0:4]:  RouteTrap,
}

var _RouteFlagNames = []string{
	_RouteFlagName_0[0:6],
	_RouteFlagName_1[0:6],
	_RouteFlagName_2[0:8],
	_RouteFlagName_3[0:6],
	_RouteFlagName_4[0:12],
	_RouteFlagName_5[0:9],
	_RouteFlagName_6[0:7],
	_RouteFlagName_7[0:4],
}

// RouteFlagString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func RouteFlagString(s string) (RouteFlag, error) {
	if val, ok := _RouteFlagNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _RouteFlagNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to RouteFlag values", s)
}

// RouteFlagValues returns all values of the enum
func RouteFlagValues() []RouteFlag {
	return _RouteFlagValues
}

// RouteFlagStrings returns a slice of all String values of the enum
func RouteFlagStrings() []string {
	strs := make([]string, len(_RouteFlagNames))
	copy(strs, _RouteFlagNames)
	return strs
}

// IsARouteFlag returns "true" if the value is listed in the enum definition. "false" otherwise
func (i RouteFlag) IsARouteFlag() bool {
	for _, v := range _RouteFlagValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for RouteFlag
func (i RouteFlag) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for RouteFlag
func (i *RouteFlag) UnmarshalText(text []byte) error {
	var err error
	*i, err = RouteFlagString(string(text))
	return err
}

const (
	_RouteProtocolName_0      = "unspecredirectkernelbootstatic"
	_RouteProtocolLowerName_0 = "unspecredirectkernelbootstatic"
	_RouteProtocolName_1      = "ramrtzebrabirddnroutedxorpntkdhcpmrtdkeepalived"
	_RouteProtocolLowerName_1 = "ramrtzebrabirddnroutedxorpntkdhcpmrtdkeepalived"
	_RouteProtocolName_2      = "babel"
	_RouteProtocolLowerName_2 = "babel"
	_RouteProtocolName_3      = "openr"
	_RouteProtocolLowerName_3 = "openr"
	_RouteProtocolName_4      = "bgpisisospfrip"
	_RouteProtocolLowerName_4 = "bgpisisospfrip"
	_RouteProtocolName_5      = "eigrp"
	_RouteProtocolLowerName_5 = "eigrp"
)

var (
	_RouteProtocolIndex_0 = [...]uint8{0, 6, 14, 20, 24, 30}
	_RouteProtocolIndex_1 = [...]uint8{0, 2, 5, 10, 14, 22, 26, 29, 33, 37, 47}
	_RouteProtocolIndex_2 = [...]uint8{0, 5}
	_RouteProtocolIndex_3 = [...]uint8{0, 5}
	_RouteProtocolIndex_4 = [...]uint8{0, 3, 7, 11, 14}
	_RouteProtocolIndex_5 = [...]uint8{0, 5}
)

func (i RouteProtocol) String() string {
	switch {
	case 0 <= i && i <= 4:
		return _RouteProtocolName_0[_RouteProtocolIndex_0[i]:_RouteProtocolIndex_0[i+1]]
	case 9 <= i && i <= 18:
		i -= 9
		return _RouteProtocolName_1[_RouteProtocolIndex_1[i]:_RouteProtocolIndex_1[i+1]]
	case i == 42:
		return _RouteProtocolName_2
	case i == 99:
		return _RouteProtocolName_3
	case 186 <= i && i <= 189:
		i -= 186
		return _RouteProtocolName_4[_RouteProtocolIndex_4[i]:_RouteProtocolIndex_4[i+1]]
	case i == 192:
		return _RouteProtocolName_5
	default:
		return fmt.Sprintf("RouteProtocol(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _RouteProtocolNoOp() {
	var x [1]struct{}
	_ = x[ProtocolUnspec-(0)]
	_ = x[ProtocolRedirect-(1)]
	_ = x[ProtocolKernel-(2)]
	_ = x[ProtocolBoot-(3)]
	_ = x[ProtocolStatic-(4)]
	_ = x[ProtocolRA-(9)]
	_ = x[ProtocolMRT-(10)]
	_ = x[ProtocolZebra-(11)]
	_ = x[ProtocolBird-(12)]
	_ = x[ProtocolDnrouted-(13)]
	_ = x[ProtocolXorp-(14)]
	_ = x[ProtocolNTK-(15)]
	_ = x[ProtocolDHCP-(16)]
	_ = x[ProtocolMRTD-(17)]
	_ = x[ProtocolKeepalived-(18)]
	_ = x[ProtocolBabel-(42)]
	_ = x[ProtocolOpenr-(99)]
	_ = x[ProtocolBGP-(186)]
	_ = x[ProtocolISIS-(187)]
	_ = x[ProtocolOSPF-(188)]
	_ = x[ProtocolRIP-(189)]
	_ = x[ProtocolEIGRP-(192)]
}

var _RouteProtocolValues = []RouteProtocol{ProtocolUnspec, ProtocolRedirect, ProtocolKernel, ProtocolBoot, ProtocolStatic, ProtocolRA, ProtocolMRT, ProtocolZebra, ProtocolBird, ProtocolDnrouted, ProtocolXorp, ProtocolNTK, ProtocolDHCP, ProtocolMRTD, ProtocolKeepalived, ProtocolBabel, ProtocolOpenr, ProtocolBGP, ProtocolISIS, ProtocolOSPF, ProtocolRIP, ProtocolEIGRP}

var _RouteProtocolNameToValueMap = map[string]RouteProtocol{
	_RouteProtocolName_0[0:6]:        ProtocolUnspec,
	_RouteProtocolLowerName_0[0:6]:   ProtocolUnspec,
	_RouteProtocolName_0[6:14]:       ProtocolRedirect,
	_RouteProtocolLowerName_0[6:14]:  ProtocolRedirect,
	_RouteProtocolName_0[14:20]:      ProtocolKernel,
	_RouteProtocolLowerName_0[14:20]: ProtocolKernel,
	_RouteProtocolName_0[20:24]:      ProtocolBoot,
	_RouteProtocolLowerName_0[20:24]: ProtocolBoot,
	_RouteProtocolName_0[24:30]:      ProtocolStatic,
	_RouteProtocolLowerName_0[24:30]: ProtocolStatic,
	_RouteProtocolName_1[0:2]:        ProtocolRA,
	_RouteProtocolLowerName_1[0:2]:   ProtocolRA,
	_RouteProtocolName_1[2:5]:        ProtocolMRT,
	_RouteProtocolLowerName_1[2:5]:   ProtocolMRT,
	_RouteProtocolName_1[5:10]:       ProtocolZebra,
	_RouteProtocolLowerName_1[5:10]:  ProtocolZebra,
	_RouteProtocolName_1[10:14]:      ProtocolBird,
	_RouteProtocolLowerName_1[10:14]: ProtocolBird,
	_RouteProtocolName_1[14:22]:      ProtocolDnrouted,
	_RouteProtocolLowerName_1[14:22]: ProtocolDnrouted,
	_RouteProtocolName_1[22:26]:      ProtocolXorp,
	_RouteProtocolLowerName_1[22:26]: ProtocolXorp,
	_RouteProtocolName_1[26:29]:      ProtocolNTK,
	_RouteProtocolLowerName_1[26:29]: ProtocolNTK,
	_RouteProtocolName_1[29:33]:      ProtocolDHCP,
	_RouteProtocolLowerName_1[29:33]: ProtocolDHCP,
	_RouteProtocolName_1[33:37]:      ProtocolMRTD,
	_RouteProtocolLowerName_1[33:37]: ProtocolMRTD,
	_RouteProtocolName_1[37:47]:      ProtocolKeepalived,
	_RouteProtocolLowerName_1[37:47]: ProtocolKeepalived,
	_RouteProtocolName_2[0:5]:        ProtocolBabel,
	_RouteProtocolLowerName_2[0:5]:   ProtocolBabel,
	_RouteProtocolName_3[0:5]:        ProtocolOpenr,
	_RouteProtocolLowerName_3[0:5]:   ProtocolOpenr,
	_RouteProtocolName_4[0:3]:        ProtocolBGP,
	_RouteProtocolLowerName_4[0:3]:   ProtocolBGP,
	_RouteProtocolName_4[3:7]:        ProtocolISIS,
	_RouteProtocolLowerName_4[3:7]:   ProtocolISIS,
	_RouteProtocolName_4[7:11]:       ProtocolOSPF,
	_RouteProtocolLowerName_4[7:11]:  ProtocolOSPF,
	_RouteProtocolName_4[11:14]:      ProtocolRIP,
	_RouteProtocolLowerName_4[11:14]: ProtocolRIP,
	_RouteProtocolName_5[0:5]:        ProtocolEIGRP,
	_RouteProtocolLowerName_5[0:5]:   ProtocolEIGRP,
}

var _RouteProtocolNames = []string{
	_RouteProtocolName_0[0:6],
	_RouteProtocolName_0[6:14],
	_RouteProtocolName_0[14:20],
	_RouteProtocolName_0[20:24],
	_RouteProtocolName_0[24:30],
	_RouteProtocolName_1[0:2],
	_RouteProtocolName_1[2:5],
	_RouteProtocolName_1[5:10],
	_RouteProtocolName_1[10:14],
	_RouteProtocolName_1[14:22],
	_RouteProtocolName_1[22:26],
	_RouteProtocolName_1[26:29],
	_RouteProtocolName_1[29:33],
	_RouteProtocolName_1[33:37],
	_RouteProtocolName_1[37:47],
	_RouteProtocolName_2[0:5],
	_RouteProtocolName_3[0:5],
	_RouteProtocolName_4[0:3],
	_RouteProtocolName_4[3:7],
	_RouteProtocolName_4[7:11],
	_RouteProtocolName_4[11:14],
	_RouteProtocolName_5[0:5],
}

// RouteProtocolString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func RouteProtocolString(s string) (RouteProtocol, error) {
	if val, ok := _RouteProtocolNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _RouteProtocolNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to RouteProtocol values", s)
}

// RouteProtocolValues returns all values of the enum
func RouteProtocolValues() []RouteProtocol {
	return _RouteProtocolValues
}

// RouteProtocolStrings returns a slice of all String values of the enum
func RouteProtocolStrings() []string {
	strs := make([]string, len(_RouteProtocolNames))
	copy(strs, _RouteProtocolNames)
	return strs
}

// IsARouteProtocol returns "true" if the value is listed in the enum definition. "false" otherwise
func (i RouteProtocol) IsARouteProtocol() bool {
	for _, v := range _RouteProtocolValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for RouteProtocol
func (i RouteProtocol) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for RouteProtocol
func (i *RouteProtocol) UnmarshalText(text []byte) error {
	var err error
	*i, err = RouteProtocolString(string(text))
	return err
}

const _RouteTypeName = "unspecunicastlocalbroadcastanycastmulticastblackholeunreachableprohibitthrownatxresolve"

var _RouteTypeIndex = [...]uint8{0, 6, 13, 18, 27, 34, 43, 52, 63, 71, 76, 79, 87}

const _RouteTypeLowerName = "unspecunicastlocalbroadcastanycastmulticastblackholeunreachableprohibitthrownatxresolve"

func (i RouteType) String() string {
	if i >= RouteType(len(_RouteTypeIndex)-1) {
		return fmt.Sprintf("RouteType(%d)", i)
	}
	return _RouteTypeName[_RouteTypeIndex[i]:_RouteTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _RouteTypeNoOp() {
	var x [1]struct{}
	_ = x[TypeUnspec-(0)]
	_ = x[TypeUnicast-(1)]
	_ = x[TypeLocal-(2)]
	_ = x[TypeBroadcast-(3)]
	_ = x[TypeAnycast-(4)]
	_ = x[TypeMulticast-(5)]
	_ = x[TypeBlackhole-(6)]
	_ = x[TypeUnreachable-(7)]
	_ = x[TypeProhibit-(8)]
	_ = x[TypeThrow-(9)]
	_ = x[TypeNAT-(10)]
	_ = x[TypeXResolve-(11)]
}

var _RouteTypeValues = []RouteType{TypeUnspec, TypeUnicast, TypeLocal, TypeBroadcast, TypeAnycast, TypeMulticast, TypeBlackhole, TypeUnreachable, TypeProhibit, TypeThrow, TypeNAT, TypeXResolve}

var _RouteTypeNameToValueMap = map[string]RouteType{
	_RouteTypeName[0:6]:        TypeUnspec,
	_RouteTypeLowerName[0:6]:   TypeUnspec,
	_RouteTypeName[6:13]:       TypeUnicast,
	_RouteTypeLowerName[6:13]:  TypeUnicast,
	_RouteTypeName[13:18]:      TypeLocal,
	_RouteTypeLowerName[13:18]: TypeLocal,
	_RouteTypeName[18:27]:      TypeBroadcast,
	_RouteTypeLowerName[18:27]: TypeBroadcast,
	_RouteTypeName[27:34]:      TypeAnycast,
	_RouteTypeLowerName[27:34]: TypeAnycast,
	_RouteTypeName[34:43]:      TypeMulticast,
	_RouteTypeLowerName[34:43]: TypeMulticast,
	_RouteTypeName[43:52]:      TypeBlackhole,
	_RouteTypeLowerName[43:52]: TypeBlackhole,
	_RouteTypeName[52:63]:      TypeUnreachable,
	_RouteTypeLowerName[52:63]: TypeUnreachable,
	_RouteTypeName[63:71]:      TypeProhibit,
	_RouteTypeLowerName[63:71]: TypeProhibit,
	_RouteTypeName[71:76]:      TypeThrow,
	_RouteTypeLowerName[71:76]: TypeThrow,
	_RouteTypeName[76:79]:      TypeNAT,
	_RouteTypeLowerName[76:79]: TypeNAT,
	_RouteTypeName[79:87]:      TypeXResolve,
	_RouteTypeLowerName[79:87]: TypeXResolve,
}

var _RouteTypeNames = []string{
	_RouteTypeName[0:6],
	_RouteTypeName[6:13],
	_RouteTypeName[13:18],
	_RouteTypeName[18:27],
	_RouteTypeName[27:34],
	_RouteTypeName[34:43],
	_RouteTypeName[43:52],
	_RouteTypeName[52:63],
	_RouteTypeName[63:71],
	_RouteTypeName[71:76],
	_RouteTypeName[76:79],
	_RouteTypeName[79:87],
}

// RouteTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func RouteTypeString(s string) (RouteType, error) {
	if val, ok := _RouteTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _RouteTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to RouteType values", s)
}

// RouteTypeValues returns all values of the enum
func RouteTypeValues() []RouteType {
	return _RouteTypeValues
}

// RouteTypeStrings returns a slice of all String values of the enum
func RouteTypeStrings() []string {
	strs := make([]string, len(_RouteTypeNames))
	copy(strs, _RouteTypeNames)
	return strs
}

// IsARouteType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i RouteType) IsARouteType() bool {
	for _, v := range _RouteTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for RouteType
func (i RouteType) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for RouteType
func (i *RouteType) UnmarshalText(text []byte) error {
	var err error
	*i, err = RouteTypeString(string(text))
	return err
}

const (
	_RoutingTableName_0      = "unspec"
	_RoutingTableLowerName_0 = "unspec"
	_RoutingTableName_1      = "defaultmainlocal"
	_RoutingTableLowerName_1 = "defaultmainlocal"
)

var (
	_RoutingTableIndex_0 = [...]uint8{0, 6}
	_RoutingTableIndex_1 = [...]uint8{0, 7, 11, 16}
)

func (i RoutingTable) String() string {
	switch {
	case i == 0:
		return _RoutingTableName_0
	case 253 <= i && i <= 255:
		i -= 253
		return _RoutingTableName_1[_RoutingTableIndex_1[i]:_RoutingTableIndex_1[i+1]]
	default:
		return fmt.Sprintf("RoutingTable(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _RoutingTableNoOp() {
	var x [1]struct{}
	_ = x[TableUnspec-(0)]
	_ = x[TableDefault-(253)]
	_ = x[TableMain-(254)]
	_ = x[TableLocal-(255)]
}

var _RoutingTableValues = []RoutingTable{TableUnspec, TableDefault, TableMain, TableLocal}

var _RoutingTableNameToValueMap = map[string]RoutingTable{
	_RoutingTableName_0[0:6]:        TableUnspec,
	_RoutingTableLowerName_0[0:6]:   TableUnspec,
	_RoutingTableName_1[0:7]:        TableDefault,
	_RoutingTableLowerName_1[0:7]:   TableDefault,
	_RoutingTableName_1[7:11]:       TableMain,
	_RoutingTableLowerName_1[7:11]:  TableMain,
	_RoutingTableName_1[11:16]:      TableLocal,
	_RoutingTableLowerName_1[11:16]: TableLocal,
}

var _RoutingTableNames = []string{
	_RoutingTableName_0[0:6],
	_RoutingTableName_1[0:7],
	_RoutingTableName_1[7:11],
	_RoutingTableName_1[11:16],
}

// RoutingTableString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func RoutingTableString(s string) (RoutingTable, error) {
	if val, ok := _RoutingTableNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _RoutingTableNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to RoutingTable values", s)
}

// RoutingTableValues returns all values of the enum
func RoutingTableValues() []RoutingTable {
	return _RoutingTableValues
}

// RoutingTableStrings returns a slice of all String values of the enum
func RoutingTableStrings() []string {
	strs := make([]string, len(_RoutingTableNames))
	copy(strs, _RoutingTableNames)
	return strs
}

// IsARoutingTable returns "true" if the value is listed in the enum definition. "false" otherwise
func (i RoutingTable) IsARoutingTable() bool {
	for _, v := range _RoutingTableValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for RoutingTable
func (i RoutingTable) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for RoutingTable
func (i *RoutingTable) UnmarshalText(text []byte) error {
	var err error
	*i, err = RoutingTableString(string(text))
	return err
}

const (
	_ScopeName_0      = "global"
	_ScopeLowerName_0 = "global"
	_ScopeName_1      = "site"
	_ScopeLowerName_1 = "site"
	_ScopeName_2      = "linkhostnowhere"
	_ScopeLowerName_2 = "linkhostnowhere"
)

var (
	_ScopeIndex_0 = [...]uint8{0, 6}
	_ScopeIndex_1 = [...]uint8{0, 4}
	_ScopeIndex_2 = [...]uint8{0, 4, 8, 15}
)

func (i Scope) String() string {
	switch {
	case i == 0:
		return _ScopeName_0
	case i == 200:
		return _ScopeName_1
	case 253 <= i && i <= 255:
		i -= 253
		return _ScopeName_2[_ScopeIndex_2[i]:_ScopeIndex_2[i+1]]
	default:
		return fmt.Sprintf("Scope(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _ScopeNoOp() {
	var x [1]struct{}
	_ = x[ScopeGlobal-(0)]
	_ = x[ScopeSite-(200)]
	_ = x[ScopeLink-(253)]
	_ = x[ScopeHost-(254)]
	_ = x[ScopeNowhere-(255)]
}

var _ScopeValues = []Scope{ScopeGlobal, ScopeSite, ScopeLink, ScopeHost, ScopeNowhere}

var _ScopeNameToValueMap = map[string]Scope{
	_ScopeName_0[0:6]:       ScopeGlobal,
	_ScopeLowerName_0[0:6]:  ScopeGlobal,
	_ScopeName_1[0:4]:       ScopeSite,
	_ScopeLowerName_1[0:4]:  ScopeSite,
	_ScopeName_2[0:4]:       ScopeLink,
	_ScopeLowerName_2[0:4]:  ScopeLink,
	_ScopeName_2[4:8]:       ScopeHost,
	_ScopeLowerName_2[4:8]:  ScopeHost,
	_ScopeName_2[8:15]:      ScopeNowhere,
	_ScopeLowerName_2[8:15]: ScopeNowhere,
}

var _ScopeNames = []string{
	_ScopeName_0[0:6],
	_ScopeName_1[0:4],
	_ScopeName_2[0:4],
	_ScopeName_2[4:8],
	_ScopeName_2[8:15],
}

// ScopeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func ScopeString(s string) (Scope, error) {
	if val, ok := _ScopeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _ScopeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Scope values", s)
}

// ScopeValues returns all values of the enum
func ScopeValues() []Scope {
	return _ScopeValues
}

// ScopeStrings returns a slice of all String values of the enum
func ScopeStrings() []string {
	strs := make([]string, len(_ScopeNames))
	copy(strs, _ScopeNames)
	return strs
}

// IsAScope returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Scope) IsAScope() bool {
	for _, v := range _ScopeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for Scope
func (i Scope) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Scope
func (i *Scope) UnmarshalText(text []byte) error {
	var err error
	*i, err = ScopeString(string(text))
	return err
}

const _StatusName = "addressesconnectivityhostnameetcfiles"

var _StatusIndex = [...]uint8{0, 9, 21, 29, 37}

const _StatusLowerName = "addressesconnectivityhostnameetcfiles"

func (i Status) String() string {
	i -= 1
	if i < 0 || i >= Status(len(_StatusIndex)-1) {
		return fmt.Sprintf("Status(%d)", i+1)
	}
	return _StatusName[_StatusIndex[i]:_StatusIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _StatusNoOp() {
	var x [1]struct{}
	_ = x[StatusAddresses-(1)]
	_ = x[StatusConnectivity-(2)]
	_ = x[StatusHostname-(3)]
	_ = x[StatusEtcFiles-(4)]
}

var _StatusValues = []Status{StatusAddresses, StatusConnectivity, StatusHostname, StatusEtcFiles}

var _StatusNameToValueMap = map[string]Status{
	_StatusName[0:9]:        StatusAddresses,
	_StatusLowerName[0:9]:   StatusAddresses,
	_StatusName[9:21]:       StatusConnectivity,
	_StatusLowerName[9:21]:  StatusConnectivity,
	_StatusName[21:29]:      StatusHostname,
	_StatusLowerName[21:29]: StatusHostname,
	_StatusName[29:37]:      StatusEtcFiles,
	_StatusLowerName[29:37]: StatusEtcFiles,
}

var _StatusNames = []string{
	_StatusName[0:9],
	_StatusName[9:21],
	_StatusName[21:29],
	_StatusName[29:37],
}

// StatusString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func StatusString(s string) (Status, error) {
	if val, ok := _StatusNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _StatusNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Status values", s)
}

// StatusValues returns all values of the enum
func StatusValues() []Status {
	return _StatusValues
}

// StatusStrings returns a slice of all String values of the enum
func StatusStrings() []string {
	strs := make([]string, len(_StatusNames))
	copy(strs, _StatusNames)
	return strs
}

// IsAStatus returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Status) IsAStatus() bool {
	for _, v := range _StatusValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for Status
func (i Status) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Status
func (i *Status) UnmarshalText(text []byte) error {
	var err error
	*i, err = StatusString(string(text))
	return err
}

const (
	_VLANProtocolName_0      = "802.1q"
	_VLANProtocolLowerName_0 = "802.1q"
	_VLANProtocolName_1      = "802.1ad"
	_VLANProtocolLowerName_1 = "802.1ad"
)

var (
	_VLANProtocolIndex_0 = [...]uint8{0, 6}
	_VLANProtocolIndex_1 = [...]uint8{0, 7}
)

func (i VLANProtocol) String() string {
	switch {
	case i == 33024:
		return _VLANProtocolName_0
	case i == 34984:
		return _VLANProtocolName_1
	default:
		return fmt.Sprintf("VLANProtocol(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _VLANProtocolNoOp() {
	var x [1]struct{}
	_ = x[VLANProtocol8021Q-(33024)]
	_ = x[VLANProtocol8021AD-(34984)]
}

var _VLANProtocolValues = []VLANProtocol{VLANProtocol8021Q, VLANProtocol8021AD}

var _VLANProtocolNameToValueMap = map[string]VLANProtocol{
	_VLANProtocolName_0[0:6]:      VLANProtocol8021Q,
	_VLANProtocolLowerName_0[0:6]: VLANProtocol8021Q,
	_VLANProtocolName_1[0:7]:      VLANProtocol8021AD,
	_VLANProtocolLowerName_1[0:7]: VLANProtocol8021AD,
}

var _VLANProtocolNames = []string{
	_VLANProtocolName_0[0:6],
	_VLANProtocolName_1[0:7],
}

// VLANProtocolString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func VLANProtocolString(s string) (VLANProtocol, error) {
	if val, ok := _VLANProtocolNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _VLANProtocolNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to VLANProtocol values", s)
}

// VLANProtocolValues returns all values of the enum
func VLANProtocolValues() []VLANProtocol {
	return _VLANProtocolValues
}

// VLANProtocolStrings returns a slice of all String values of the enum
func VLANProtocolStrings() []string {
	strs := make([]string, len(_VLANProtocolNames))
	copy(strs, _VLANProtocolNames)
	return strs
}

// IsAVLANProtocol returns "true" if the value is listed in the enum definition. "false" otherwise
func (i VLANProtocol) IsAVLANProtocol() bool {
	for _, v := range _VLANProtocolValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for VLANProtocol
func (i VLANProtocol) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for VLANProtocol
func (i *VLANProtocol) UnmarshalText(text []byte) error {
	var err error
	*i, err = VLANProtocolString(string(text))
	return err
}
